<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>OAA Ontology Visualiser</title>
<script src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { font-family: 'Segoe UI', system-ui, sans-serif; background: #0f1117; color: #e0e0e0; height: 100vh; display: flex; flex-direction: column; }
  header { background: #1a1d27; padding: 12px 24px; display: flex; align-items: center; gap: 16px; border-bottom: 1px solid #2a2d37; }
  header h1 { font-size: 16px; font-weight: 600; color: #9dfff5; }
  header .stats { font-size: 13px; color: #888; margin-left: auto; }
  .toolbar { background: #1a1d27; padding: 8px 24px; display: flex; gap: 8px; border-bottom: 1px solid #2a2d37; }
  .toolbar button, .toolbar label { background: #2a2d37; border: 1px solid #3a3d47; color: #ccc; padding: 6px 14px; border-radius: 6px; cursor: pointer; font-size: 13px; }
  .toolbar button:hover, .toolbar label:hover { background: #3a3d47; color: #fff; }
  .toolbar button.active { background: #017c75; border-color: #017c75; color: #fff; }
  .toolbar input[type="file"] { display: none; }
  .toolbar select { background: #2a2d37; border: 1px solid #3a3d47; color: #ccc; padding: 6px 10px; border-radius: 6px; font-size: 13px; }
  #graph-container { flex: 1; position: relative; overflow: hidden; min-height: 0; }
  #network { width: 100%; height: 100%; position: absolute; inset: 0; }
  #drop-zone { position: absolute; inset: 0; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 16px; z-index: 10; }
  #drop-zone.hidden { display: none; }
  #drop-zone .drop-area { border: 2px dashed #3a3d47; border-radius: 16px; padding: 60px 80px; text-align: center; transition: border-color 0.2s; }
  #drop-zone .drop-area.dragover { border-color: #9dfff5; background: rgba(157,255,245,0.05); }
  #drop-zone h2 { font-size: 20px; color: #9dfff5; margin-bottom: 8px; }
  #drop-zone p { color: #888; font-size: 14px; }
  #drop-zone .formats { color: #666; font-size: 12px; margin-top: 12px; }
  .sidebar { position: absolute; right: 0; top: 0; bottom: 0; width: 380px; background: #1a1d27; border-left: 1px solid #2a2d37; padding: 16px; overflow-y: auto; z-index: 5; transform: translateX(100%); transition: transform 0.2s; }
  .sidebar.open { transform: translateX(0); }
  .sidebar h3 { font-size: 14px; color: #9dfff5; margin-bottom: 12px; }
  .sidebar .field { margin-bottom: 10px; }
  .sidebar .field-label { font-size: 11px; color: #888; text-transform: uppercase; letter-spacing: 0.5px; }
  .sidebar .field-value { font-size: 13px; color: #e0e0e0; margin-top: 2px; word-break: break-word; }
  .sidebar .close-btn { position: absolute; top: 12px; right: 12px; background: none; border: none; color: #888; cursor: pointer; font-size: 18px; }
  .sidebar-tabs { display: flex; gap: 4px; margin-bottom: 12px; border-bottom: 1px solid #2a2d37; padding-bottom: 8px; }
  .sidebar-tab { background: none; border: none; color: #888; padding: 6px 12px; cursor: pointer; font-size: 12px; border-radius: 4px; }
  .sidebar-tab:hover { color: #ccc; background: #2a2d37; }
  .sidebar-tab.active { color: #9dfff5; background: #2a2d37; }
  .connection-item { display: flex; align-items: center; gap: 8px; padding: 6px 8px; border-radius: 4px; cursor: pointer; font-size: 12px; margin-bottom: 4px; background: #22252f; }
  .connection-item:hover { background: #2a2d37; }
  .connection-arrow { color: #666; font-size: 14px; }
  .connection-label { color: #9dfff5; font-size: 11px; flex-shrink: 0; }
  .connection-node { color: #e0e0e0; }
  .conn-section { margin-bottom: 12px; }
  .conn-section h4 { font-size: 11px; color: #888; text-transform: uppercase; margin-bottom: 6px; }
  .prop-row { display: flex; justify-content: space-between; align-items: flex-start; padding: 6px 8px; background: #22252f; border-radius: 4px; margin-bottom: 4px; font-size: 12px; }
  .prop-name { color: #e0e0e0; }
  .prop-type { color: #888; font-size: 11px; }
  .prop-required { color: #FF9800; font-size: 10px; margin-left: 4px; }
  .data-instance { background: #22252f; border-radius: 6px; padding: 10px; margin-bottom: 8px; font-size: 12px; }
  .data-instance-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; padding-bottom: 6px; border-bottom: 1px solid #2a2d37; }
  .data-instance-id { color: #9dfff5; font-weight: 500; }
  .data-instance-type { font-size: 10px; padding: 2px 6px; border-radius: 8px; }
  .data-instance-type.typical { background: #166534; color: #86efac; }
  .data-instance-type.edge { background: #1e40af; color: #93c5fd; }
  .data-instance-type.boundary { background: #854d0e; color: #fcd34d; }
  .data-instance-type.invalid { background: #7f1d1d; color: #fca5a5; }
  .data-row { display: flex; gap: 8px; margin-bottom: 4px; }
  .data-key { color: #888; min-width: 80px; }
  .data-value { color: #e0e0e0; word-break: break-all; }
  .no-data { color: #666; font-size: 12px; font-style: italic; padding: 12px; text-align: center; }
  .legend { position: absolute; bottom: 16px; left: 16px; background: #1a1d27; border: 1px solid #2a2d37; border-radius: 8px; padding: 12px; z-index: 5; font-size: 12px; }
  .legend-item { display: flex; align-items: center; gap: 8px; margin-bottom: 4px; }
  .legend-dot { width: 10px; height: 10px; border-radius: 50%; }
  .audit-panel { position: absolute; left: 0; top: 0; bottom: 0; width: 340px; background: #1a1d27; border-right: 1px solid #2a2d37; padding: 16px; overflow-y: auto; z-index: 6; transform: translateX(-100%); transition: transform 0.2s; }
  .audit-panel.open { transform: translateX(0); }
  .audit-panel h3 { font-size: 14px; color: #9dfff5; margin-bottom: 12px; }
  .audit-panel .close-btn { position: absolute; top: 12px; right: 12px; background: none; border: none; color: #888; cursor: pointer; font-size: 18px; }
  .audit-section { margin-bottom: 16px; }
  .audit-section h4 { font-size: 12px; color: #888; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 6px; }
  .audit-item { font-size: 12px; color: #ccc; padding: 4px 8px; border-radius: 4px; cursor: pointer; margin-bottom: 2px; }
  .audit-item:hover { background: #2a2d37; color: #fff; }
  .audit-badge { display: inline-block; background: #2a2d37; border: 1px solid #3a3d47; color: #ccc; padding: 2px 8px; border-radius: 10px; font-size: 11px; margin-left: 6px; }
  .audit-badge.warn { background: #553016; border-color: #834a22; color: #ffb48e; }
  .audit-badge.ok { background: #166534; border-color: #15803d; color: #86efac; }
</style>
</head>
<body>

<header>
  <h1>OAA Ontology Visualiser</h1>
  <span id="file-name" style="font-size:13px; color:#666;"></span>
  <span class="stats" id="stats"></span>
</header>

<div class="toolbar">
  <label for="file-input">Open JSON File</label>
  <input type="file" id="file-input" accept=".json,.jsonld">
  <button id="btn-physics" class="active" onclick="togglePhysics()">Physics</button>
  <select id="layout-select" onchange="changeLayout()">
    <option value="physics">Force-directed</option>
    <option value="hierarchical">Hierarchical</option>
    <option value="circular">Circular</option>
  </select>
  <button onclick="fitGraph()">Fit View</button>
  <button onclick="exportPNG()">Export PNG</button>
  <button id="btn-sidebar" onclick="toggleSidebar()">Details</button>
  <button id="btn-audit" onclick="toggleAudit()">Audit</button>
  <span style="border-left:1px solid #3a3d47; height:24px;"></span>
  <button onclick="loadFromGitHub()">Load from GitHub</button>
  <button onclick="loadTestDataFile()">+ Test Data</button>
</div>

<div id="graph-container">
  <div id="drop-zone">
    <div class="drop-area" id="drop-area">
      <h2>Drop JSON Ontology Here</h2>
      <p>or click "Open JSON File" above</p>
      <div class="formats">Supports: JSON-LD, Registry Entry, UniRegistry, @graph, Agent Registry<br>Or use "Load from GitHub" to fetch from a private repo</div>
    </div>
  </div>
  <div id="network"></div>
  <div class="sidebar" id="sidebar">
    <button class="close-btn" onclick="toggleSidebar()">&times;</button>
    <h3 id="sidebar-title">Node Details</h3>
    <div class="sidebar-tabs" id="sidebar-tabs">
      <button class="sidebar-tab active" onclick="switchTab('details')">Details</button>
      <button class="sidebar-tab" onclick="switchTab('connections')">Connections</button>
      <button class="sidebar-tab" onclick="switchTab('schema')">Schema</button>
      <button class="sidebar-tab" onclick="switchTab('data')">Data</button>
    </div>
    <div id="tab-details" class="tab-content"><p style="color:#666">Click a node to see details</p></div>
    <div id="tab-connections" class="tab-content" style="display:none;"></div>
    <div id="tab-schema" class="tab-content" style="display:none;"></div>
    <div id="tab-data" class="tab-content" style="display:none;"></div>
  </div>
  <div class="legend" id="legend" style="display:none;"></div>
  <div class="audit-panel" id="audit-panel">
    <button class="close-btn" onclick="toggleAudit()">&times;</button>
    <h3>Graph Audit</h3>
    <div id="audit-content"><p style="color:#666">Load a graph to see audit results</p></div>
  </div>
</div>

<script>
let network = null;
let physicsEnabled = true;
let currentData = null;
let lastAudit = null;
let lastParsed = null;
let currentNodeId = null;

const TYPE_COLORS = {
  'class': '#4CAF50', 'core': '#4CAF50', 'framework': '#2196F3',
  'supporting': '#FF9800', 'agent': '#E91E63', 'external': '#9E9E9E',
  'layer': '#00BCD4', 'concept': '#9C27B0', 'default': '#017c75'
};

const EDGE_COLORS = {
  'subClassOf': '#888', 'inheritance': '#888', 'relationship': '#4CAF50',
  'binding': '#FF9800', 'value_chain': '#2196F3', 'default': '#555'
};

// --- File input & drag-drop ---
document.getElementById('file-input').addEventListener('change', function(e) {
  const file = e.target.files[0];
  if (file) loadFile(file);
});

const dropArea = document.getElementById('drop-area');
const dropZone = document.getElementById('drop-zone');

['dragenter', 'dragover'].forEach(evt => {
  dropArea.addEventListener(evt, e => { e.preventDefault(); dropArea.classList.add('dragover'); });
});
['dragleave', 'drop'].forEach(evt => {
  dropArea.addEventListener(evt, e => { e.preventDefault(); dropArea.classList.remove('dragover'); });
});
dropArea.addEventListener('drop', e => {
  const file = e.dataTransfer.files[0];
  if (file) loadFile(file);
});

function loadFile(file) {
  document.getElementById('file-name').textContent = file.name;
  const reader = new FileReader();
  reader.onload = function(e) {
    try {
      const data = JSON.parse(e.target.result);
      currentData = data;
      const parsed = parseOntology(data, file.name);
      if (parsed.nodes.length === 0) {
        alert('No nodes parsed from this file. Keys found: ' + Object.keys(data).join(', '));
        return;
      }
      renderGraph(parsed);
      dropZone.classList.add('hidden');
    } catch (err) {
      alert('Failed to parse JSON: ' + err.message);
    }
  };
  reader.readAsText(file);
}

// --- Fix 1: Unified format detection ---
function detectFormat(data) {
  if (data.agents && Array.isArray(data.agents)) return 'agent-registry';
  if (data.registryEntry) return 'registry-entry';
  if (data.ontologyDefinition) return 'uni-registry';
  if (data.entities && Array.isArray(data.entities)) return 'pf-ontology';
  if (data.classes || data['@graph']) return 'jsonld';
  return 'generic';
}

function parseOntology(data, source) {
  const nodes = [];
  const edges = [];
  const seen = new Set();
  const diagnostics = { format: '', stubNodes: [], orphanEdges: [] };

  function addNode(id, label, type, description, properties) {
    if (seen.has(id)) return;
    seen.add(id);
    nodes.push({ id, label: label || id, entityType: type || 'default', description: description || '', properties: properties || {} });
  }

  function addEdge(from, to, label, type) {
    edges.push({ from, to, label: label || '', edgeType: type || 'relationship' });
  }

  const format = detectFormat(data);
  diagnostics.format = format;

  // --- Parse by detected format (mutually exclusive) ---
  if (format === 'agent-registry') {
    data.agents.forEach(agent => {
      addNode(agent.id, agent.name || agent.id, 'agent', agent.purpose || agent.description, agent);
      if (agent.dependencies) agent.dependencies.forEach(dep => addEdge(agent.id, dep, 'depends on', 'binding'));
      if (agent.layer) {
        const layerId = 'layer:' + agent.layer;
        addNode(layerId, agent.layer, 'layer', 'Agent layer');
        addEdge(agent.id, layerId, 'in layer', 'binding');
      }
    });
  }

  else if (format === 'registry-entry') {
    const re = data.registryEntry;
    const name = re.name || re.ontologyName || source;
    addNode('root', name, 'core', re.description || re.summary || '');
    if (re.summary && re.summary.entities) {
      re.summary.entities.forEach(ent => {
        const id = ent.id || ent.name;
        addNode(id, ent.name || id, ent.entityType || 'class', ent.description || '', ent);
        addEdge('root', id, 'contains', 'relationship');
      });
    }
    if (re.summary && re.summary.relationships) {
      re.summary.relationships.forEach(rel => {
        if (rel.source && rel.target) addEdge(rel.source, rel.target, rel.label || rel.name || '', 'relationship');
      });
    }
  }

  else if (format === 'uni-registry') {
    const od = data.ontologyDefinition;
    const ontName = (data.registryMetadata && data.registryMetadata.name) || od.name || source;
    const ontDesc = (data.registryMetadata && data.registryMetadata.description) || od.description || '';

    const graph = od['@graph'] || [];
    graph.forEach(cls => {
      const id = cls['@id'] || cls.id;
      const label = cls['rdfs:label'] || cls.name || cls.label || id;
      const desc = cls['rdfs:comment'] || cls.description || '';
      if (id) addNode(id, label, 'class', desc, cls);
      const parent = cls['rdfs:subClassOf'];
      if (parent) {
        const parentId = typeof parent === 'object' ? (parent['@id'] || parent.id) : parent;
        if (parentId) {
          if (!seen.has(parentId)) addNode(parentId, parentId.replace(/.*[:#]/, ''), 'external', 'schema.org / base type');
          addEdge(id, parentId, 'subClassOf', 'inheritance');
        }
      }
    });

    if (od.entities) {
      od.entities.forEach(ent => {
        const id = ent['@id'] || ent.id || ent.name;
        addNode(id, ent.name || ent['rdfs:label'] || id, ent.entityType || 'class', ent.description || '', ent);
      });
    }

    if (od.relationships) {
      od.relationships.forEach(rel => {
        const label = rel['rdfs:label'] || rel.name || rel.label || '';
        let domain = rel['rdfs:domain'] || rel.source;
        let range = rel['rdfs:range'] || rel.target;
        if (typeof domain !== 'string') domain = null;
        if (typeof range !== 'string') range = null;
        if (domain && range) {
          if (!seen.has(domain)) addNode(domain, domain.replace(/.*[:#]/, ''), 'external', '');
          if (!seen.has(range)) addNode(range, range.replace(/.*[:#]/, ''), 'external', '');
          addEdge(domain, range, label, 'relationship');
        }
        const domains = rel.domainIncludes;
        const ranges = rel.rangeIncludes;
        if (domains && ranges) {
          (Array.isArray(domains) ? domains : [domains]).forEach(d => {
            (Array.isArray(ranges) ? ranges : [ranges]).forEach(r => {
              if (!seen.has(d)) addNode(d, d.replace(/.*[:#]/, ''), 'external', '');
              if (!seen.has(r)) addNode(r, r.replace(/.*[:#]/, ''), 'external', '');
              addEdge(d, r, label, 'relationship');
            });
          });
        }
      });
    }

    if (ontName && nodes.length > 0) {
      addNode(data['@id'] || 'ont:root', ontName, 'core', ontDesc);
    }
  }

  else if (format === 'pf-ontology') {
    const ontName = (data.metadata && data.metadata.name) || data.name || source;
    data.entities.forEach(ent => {
      const id = ent['@id'] || ent.id || ent.name;
      const label = ent.name || ent.label || ent['rdfs:label'] || id;
      const desc = ent.description || ent['rdfs:comment'] || '';
      const type = ent.entityType || (ent['@type'] || '').replace(/.*:/, '') || 'class';
      if (id) addNode(id, label, type.toLowerCase(), desc, ent);
      if (ent.schemaOrgBase) {
        addNode(ent.schemaOrgBase, ent.schemaOrgBase.replace('schema:', ''), 'external', 'schema.org type');
        addEdge(id, ent.schemaOrgBase, 'extends', 'inheritance');
      }
    });

    if (data.relationships && Array.isArray(data.relationships)) {
      data.relationships.forEach(rel => {
        const label = rel.name || rel.label || rel['@id'] || '';
        const domains = rel.domainIncludes || (rel.domain ? [rel.domain] : []);
        const ranges = rel.rangeIncludes || (rel.range ? [rel.range] : []);
        domains.forEach(d => {
          ranges.forEach(r => {
            if (!seen.has(d)) addNode(d, d.replace(/.*:/, ''), 'external', '');
            if (!seen.has(r)) addNode(r, r.replace(/.*:/, ''), 'external', '');
            addEdge(d, r, label, rel.linkedOntology ? 'binding' : 'relationship');
          });
        });
      });
    }

    if (data.metadata && data.metadata.dependencies) {
      const rootId = data['@id'] || 'root';
      addNode(rootId, ontName, 'core', data.metadata.description || '');
      data.metadata.dependencies.forEach(dep => {
        addNode(dep, dep.replace(/.*:/, ''), 'external', 'Dependency');
        addEdge(rootId, dep, 'depends on', 'binding');
      });
    }
  }

  else if (format === 'jsonld') {
    const classes = data.classes || data['@graph'] || [];
    (Array.isArray(classes) ? classes : []).forEach(cls => {
      const id = cls['@id'] || cls.id || cls.name;
      const label = cls['rdfs:label'] || cls.label || cls.name || id;
      const desc = cls['rdfs:comment'] || cls.description || '';
      const type = cls.entityType || cls.type || 'class';
      if (id) addNode(id, label, type, desc, cls.properties || cls);
      const parent = cls['rdfs:subClassOf'] || cls.subClassOf || cls.parentClass;
      if (parent) {
        const parentId = typeof parent === 'object' ? (parent['@id'] || parent.id) : parent;
        if (parentId) { addNode(parentId, parentId, 'class', ''); addEdge(id, parentId, 'subClassOf', 'inheritance'); }
      }
    });
    const rels = data.relationships || data.properties || [];
    (Array.isArray(rels) ? rels : []).forEach(rel => {
      const src = rel.source || rel.domain || rel.from;
      const tgt = rel.target || rel.range || rel.to;
      const label = rel.label || rel.name || rel['rdfs:label'] || '';
      if (src && tgt) addEdge(src, tgt, label, 'relationship');
    });
  }

  else { // generic
    addNode('root', source, 'core', 'Root');
    for (const [key, val] of Object.entries(data)) {
      if (key.startsWith('@') || key.startsWith('$')) continue;
      if (typeof val === 'object' && val !== null && !Array.isArray(val)) {
        addNode(key, val.name || val.label || key, val.entityType || val.type || 'concept', val.description || '');
        addEdge('root', key, 'contains', 'relationship');
        for (const [k2, v2] of Object.entries(val)) {
          if (typeof v2 === 'object' && v2 !== null && !Array.isArray(v2) && !k2.startsWith('@')) {
            const childId = key + '.' + k2;
            addNode(childId, v2.name || v2.label || k2, v2.entityType || 'supporting', v2.description || '');
            addEdge(key, childId, k2, 'relationship');
          }
        }
      } else if (Array.isArray(val)) {
        val.forEach((item, i) => {
          if (typeof item === 'object' && item !== null) {
            const id = item.id || item.name || key + '_' + i;
            addNode(id, item.name || item.label || id, item.entityType || item.type || 'class', item.description || '', item);
            addEdge('root', id, key, 'relationship');
          }
        });
      }
    }
  }

  // --- Fix 2: Edge validation — ensure all edge endpoints exist ---
  edges.forEach(e => {
    if (!seen.has(e.from)) {
      addNode(e.from, e.from.replace(/.*[:#]/, ''), 'external', 'Auto-created stub (missing reference)');
      diagnostics.stubNodes.push(e.from);
    }
    if (!seen.has(e.to)) {
      addNode(e.to, e.to.replace(/.*[:#]/, ''), 'external', 'Auto-created stub (missing reference)');
      diagnostics.stubNodes.push(e.to);
    }
  });

  return { nodes, edges, name: data.name || data.ontologyName || source, diagnostics };
}

// --- Fix 4 & 5: Graph audit ---
function auditGraph(parsed) {
  const nodeIds = new Set(parsed.nodes.map(n => n.id));
  const edgeSet = new Map(); // nodeId -> { in: count, out: count }
  nodeIds.forEach(id => edgeSet.set(id, { in: 0, out: 0 }));
  parsed.edges.forEach(e => {
    if (edgeSet.has(e.from)) edgeSet.get(e.from).out++;
    if (edgeSet.has(e.to)) edgeSet.get(e.to).in++;
  });

  // Isolated nodes (zero edges)
  const isolated = parsed.nodes.filter(n => {
    const counts = edgeSet.get(n.id);
    return counts && counts.in === 0 && counts.out === 0;
  });

  // Connected components via BFS
  const adj = new Map();
  nodeIds.forEach(id => adj.set(id, []));
  parsed.edges.forEach(e => {
    if (adj.has(e.from)) adj.get(e.from).push(e.to);
    if (adj.has(e.to)) adj.get(e.to).push(e.from);
  });
  const visited = new Set();
  const components = [];
  nodeIds.forEach(id => {
    if (visited.has(id)) return;
    const component = [];
    const queue = [id];
    while (queue.length > 0) {
      const cur = queue.shift();
      if (visited.has(cur)) continue;
      visited.add(cur);
      component.push(cur);
      (adj.get(cur) || []).forEach(nb => { if (!visited.has(nb)) queue.push(nb); });
    }
    components.push(component);
  });
  components.sort((a, b) => b.length - a.length);

  return {
    format: parsed.diagnostics.format,
    totalNodes: parsed.nodes.length,
    totalEdges: parsed.edges.length,
    isolated,
    components,
    stubNodes: parsed.diagnostics.stubNodes,
    mainComponentSize: components.length > 0 ? components[0].length : 0,
    disconnectedCount: components.length - 1
  };
}

function renderAuditPanel(audit) {
  lastAudit = audit;
  const el = document.getElementById('audit-content');
  let html = '';

  // Summary
  html += `<div class="audit-section"><h4>Summary</h4>`;
  html += `<div class="audit-item">Format: <strong>${audit.format}</strong></div>`;
  html += `<div class="audit-item">${audit.totalNodes} nodes, ${audit.totalEdges} edges</div>`;
  html += `<div class="audit-item">Connected components: ${audit.components.length} `;
  html += audit.disconnectedCount === 0
    ? `<span class="audit-badge ok">Fully connected</span>`
    : `<span class="audit-badge warn">${audit.disconnectedCount} disconnected</span>`;
  html += `</div>`;
  html += `<div class="audit-item">Main component: ${audit.mainComponentSize} nodes</div>`;
  html += `</div>`;

  // Stub nodes
  if (audit.stubNodes.length > 0) {
    html += `<div class="audit-section"><h4>Auto-created stubs <span class="audit-badge warn">${audit.stubNodes.length}</span></h4>`;
    audit.stubNodes.forEach(id => {
      html += `<div class="audit-item" onclick="focusNode('${id.replace(/'/g, "\\'")}')">${id}</div>`;
    });
    html += `</div>`;
  }

  // Isolated nodes
  if (audit.isolated.length > 0) {
    html += `<div class="audit-section"><h4>Isolated nodes (silos) <span class="audit-badge warn">${audit.isolated.length}</span></h4>`;
    audit.isolated.forEach(n => {
      html += `<div class="audit-item" onclick="focusNode('${n.id.replace(/'/g, "\\'")}')">${n.label} <span style="color:#666">(${n.entityType})</span></div>`;
    });
    html += `</div>`;
  }

  // Disconnected components (skip the main one)
  if (audit.components.length > 1) {
    html += `<div class="audit-section"><h4>Disconnected clusters</h4>`;
    audit.components.slice(1).forEach((comp, i) => {
      const preview = comp.slice(0, 3).join(', ') + (comp.length > 3 ? '...' : '');
      html += `<div class="audit-item" onclick="focusNodes(${JSON.stringify(comp)})">Cluster ${i + 1}: ${comp.length} nodes — ${preview}</div>`;
    });
    html += `</div>`;
  }

  if (audit.stubNodes.length === 0 && audit.isolated.length === 0 && audit.disconnectedCount === 0) {
    html += `<div class="audit-section"><div class="audit-item" style="color:#86efac;">Graph is fully connected with no issues.</div></div>`;
  }

  el.innerHTML = html;
}

function focusNode(id) {
  if (network) { network.selectNodes([id]); network.focus(id, { scale: 1.5, animation: true }); }
}

function focusNodes(ids) {
  if (network) { network.selectNodes(ids); network.fit({ nodes: ids, animation: true }); }
}

// --- Rendering ---
function renderGraph(parsed) {
  lastParsed = parsed; // Store for connections/schema/data tabs

  // Fix 5: detect silos for visual highlighting
  const audit = auditGraph(parsed);
  renderAuditPanel(audit);
  const siloNodeIds = new Set();
  audit.isolated.forEach(n => siloNodeIds.add(n.id));
  if (audit.components.length > 1) {
    audit.components.slice(1).forEach(comp => comp.forEach(id => siloNodeIds.add(id)));
  }

  const visNodes = parsed.nodes.map(n => {
    const isSilo = siloNodeIds.has(n.id);
    return {
      id: n.id,
      label: n.label,
      color: {
        background: TYPE_COLORS[n.entityType] || TYPE_COLORS.default,
        border: isSilo ? '#FF9800' : '#222',
        highlight: { background: '#9dfff5', border: '#017c75' }
      },
      borderWidth: isSilo ? 3 : 2,
      borderWidthSelected: 4,
      shapeProperties: { borderDashes: isSilo ? [6, 3] : false },
      font: { color: '#e0e0e0', size: 13 },
      shape: n.entityType === 'agent' ? 'star' : n.entityType === 'layer' ? 'box' : 'dot',
      size: n.entityType === 'agent' ? 25 : n.entityType === 'core' ? 30 : 20,
      title: n.description || n.label,
      _data: n
    };
  });

  // Fix 3: improved edge rendering
  const visEdges = parsed.edges.map(e => ({
    from: e.from,
    to: e.to,
    label: e.label,
    color: { color: EDGE_COLORS[e.edgeType] || EDGE_COLORS.default, highlight: '#9dfff5' },
    font: { color: '#888', size: 10, strokeWidth: 2, strokeColor: '#0f1117' },
    arrows: 'to',
    dashes: e.edgeType === 'inheritance',
    width: e.edgeType === 'binding' ? 2.5 : 1.5,
    smooth: { type: 'continuous', roundness: 0.3 }
  }));

  const container = document.getElementById('network');
  const data = { nodes: new vis.DataSet(visNodes), edges: new vis.DataSet(visEdges) };

  const options = {
    physics: {
      enabled: physicsEnabled,
      stabilization: { iterations: 200 },
      barnesHut: { gravitationalConstant: -3000, springLength: 150 }
    },
    interaction: { hover: true, tooltipDelay: 200 },
    nodes: { borderWidth: 2 },
    edges: { smooth: { type: 'continuous', roundness: 0.3 } },
    layout: {}
  };

  network = new vis.Network(container, data, options);

  network.once('stabilizationIterationsDone', function() {
    network.fit({ animation: true });
  });

  network.on('click', function(params) {
    if (params.nodes.length > 0) {
      const nodeId = params.nodes[0];
      const node = visNodes.find(n => n.id === nodeId);
      if (node) showNodeDetails(node._data);
    }
  });

  // Double-click to focus and drill into connections
  network.on('doubleClick', function(params) {
    if (params.nodes.length > 0) {
      const nodeId = params.nodes[0];
      const node = visNodes.find(n => n.id === nodeId);
      if (node) {
        showNodeDetails(node._data);
        switchTab('connections');
      }
    }
  });

  document.getElementById('stats').textContent =
    `${parsed.nodes.length} nodes | ${parsed.edges.length} edges | ${parsed.name} [${parsed.diagnostics.format}]`;

  buildLegend(parsed.nodes);
}

function showNodeDetails(node) {
  const sidebar = document.getElementById('sidebar');
  sidebar.classList.add('open');
  currentNodeId = node.id;

  document.getElementById('sidebar-title').textContent = node.label || node.id;

  // Details tab
  let detailsHtml = '';
  detailsHtml += field('ID', node.id);
  detailsHtml += field('Label', node.label);
  detailsHtml += field('Type', node.entityType);
  if (node.description) detailsHtml += field('Description', node.description);

  if (node.properties && typeof node.properties === 'object') {
    for (const [k, v] of Object.entries(node.properties)) {
      if (['id', 'name', 'label', 'description', 'entityType', 'type', '@id', '@type', 'properties'].includes(k)) continue;
      const val = typeof v === 'object' ? JSON.stringify(v, null, 2) : v;
      detailsHtml += field(k, val);
    }
  }
  document.getElementById('tab-details').innerHTML = detailsHtml;

  // Connections tab
  renderConnectionsTab(node.id);

  // Schema tab
  renderSchemaTab(node);

  // Data tab
  renderDataTab(node.id);

  // Reset to details tab
  switchTab('details');
}

function renderConnectionsTab(nodeId) {
  if (!lastParsed) return;

  const incoming = lastParsed.edges.filter(e => e.to === nodeId);
  const outgoing = lastParsed.edges.filter(e => e.from === nodeId);

  let html = '';

  // Outgoing connections
  html += `<div class="conn-section"><h4>Outgoing (${outgoing.length})</h4>`;
  if (outgoing.length === 0) {
    html += '<p class="no-data">No outgoing connections</p>';
  } else {
    outgoing.forEach(e => {
      const targetNode = lastParsed.nodes.find(n => n.id === e.to);
      const targetLabel = targetNode ? targetNode.label : e.to;
      html += `<div class="connection-item" onclick="navigateToNode('${e.to.replace(/'/g, "\\'")}')">
        <span class="connection-arrow">→</span>
        <span class="connection-label">${e.label || 'relates to'}</span>
        <span class="connection-node">${targetLabel}</span>
      </div>`;
    });
  }
  html += '</div>';

  // Incoming connections
  html += `<div class="conn-section"><h4>Incoming (${incoming.length})</h4>`;
  if (incoming.length === 0) {
    html += '<p class="no-data">No incoming connections</p>';
  } else {
    incoming.forEach(e => {
      const sourceNode = lastParsed.nodes.find(n => n.id === e.from);
      const sourceLabel = sourceNode ? sourceNode.label : e.from;
      html += `<div class="connection-item" onclick="navigateToNode('${e.from.replace(/'/g, "\\'")}')">
        <span class="connection-arrow">←</span>
        <span class="connection-label">${e.label || 'relates to'}</span>
        <span class="connection-node">${sourceLabel}</span>
      </div>`;
    });
  }
  html += '</div>';

  // Summary
  const total = incoming.length + outgoing.length;
  html += `<div class="conn-section"><h4>Summary</h4>`;
  html += `<div style="font-size:12px; color:#ccc;">Total connections: ${total}</div>`;
  if (total === 0) {
    html += `<div style="font-size:12px; color:#FF9800; margin-top:4px;">This node is isolated (no edges)</div>`;
  }
  html += '</div>';

  document.getElementById('tab-connections').innerHTML = html;
}

function renderSchemaTab(node) {
  let html = '';
  const props = node.properties || {};

  // Extract schema properties
  const schemaProps = props.properties || props.attributes || [];

  if (Array.isArray(schemaProps) && schemaProps.length > 0) {
    html += '<div class="conn-section"><h4>Properties</h4>';
    schemaProps.forEach(p => {
      const name = p.name || p['@id'] || p.id || 'unknown';
      const type = p.type || p.dataType || p['@type'] || p.range || 'any';
      const required = p.required || p.minCount > 0;
      html += `<div class="prop-row">
        <span class="prop-name">${name}${required ? '<span class="prop-required">*</span>' : ''}</span>
        <span class="prop-type">${type}</span>
      </div>`;
    });
    html += '</div>';
  }

  // Check for inline property definitions in the entity itself
  const inlineProps = [];
  for (const [k, v] of Object.entries(props)) {
    if (['id', 'name', 'label', 'description', 'entityType', 'type', '@id', '@type', 'properties', 'attributes', 'schemaOrgBase'].includes(k)) continue;
    if (typeof v === 'string' || typeof v === 'number' || typeof v === 'boolean') {
      inlineProps.push({ name: k, type: typeof v, value: v });
    }
  }

  if (inlineProps.length > 0) {
    html += '<div class="conn-section"><h4>Attributes</h4>';
    inlineProps.forEach(p => {
      html += `<div class="prop-row">
        <span class="prop-name">${p.name}</span>
        <span class="prop-type">${p.type}</span>
      </div>`;
    });
    html += '</div>';
  }

  // Schema.org mapping
  if (props.schemaOrgBase) {
    html += '<div class="conn-section"><h4>Schema.org Base</h4>';
    html += `<div style="font-size:12px; color:#9dfff5;">${props.schemaOrgBase}</div>`;
    html += '</div>';
  }

  if (!schemaProps.length && !inlineProps.length && !props.schemaOrgBase) {
    html = '<p class="no-data">No schema information available for this entity</p>';
  }

  document.getElementById('tab-schema').innerHTML = html;
}

function renderDataTab(nodeId) {
  let html = '';

  // Look for test data in currentData
  const testData = findTestData(nodeId);

  if (testData.length === 0) {
    html = '<p class="no-data">No data instances found for this entity.<br><br>Load an ontology with testData or instances to see sample values.</p>';
  } else {
    html += `<div style="font-size:11px; color:#888; margin-bottom:12px;">${testData.length} instance(s) found</div>`;
    testData.forEach((instance, idx) => {
      const instanceType = instance._dataType || 'typical';
      html += `<div class="data-instance">
        <div class="data-instance-header">
          <span class="data-instance-id">${instance.id || instance['@id'] || instance.name || 'Instance ' + (idx + 1)}</span>
          <span class="data-instance-type ${instanceType}">${instanceType}</span>
        </div>`;

      for (const [k, v] of Object.entries(instance)) {
        if (k === '_dataType' || k === '_entityType') continue;
        const displayVal = typeof v === 'object' ? JSON.stringify(v) : v;
        html += `<div class="data-row">
          <span class="data-key">${k}</span>
          <span class="data-value">${displayVal}</span>
        </div>`;
      }
      html += '</div>';
    });
  }

  document.getElementById('tab-data').innerHTML = html;
}

function findTestData(entityId) {
  if (!currentData) return [];

  const results = [];

  // Check various test data locations
  const testDataSources = [
    currentData.testData,
    currentData.testInstances,
    currentData.instances,
    currentData.sampleData,
    currentData.data,
    currentData.ontologyDefinition?.testData,
    currentData.registryEntry?.testData
  ];

  for (const source of testDataSources) {
    if (!source) continue;

    // If source is an object with entity keys
    if (typeof source === 'object' && !Array.isArray(source)) {
      // Check for exact match or partial match
      for (const [key, instances] of Object.entries(source)) {
        if (key === entityId || key.toLowerCase() === entityId.toLowerCase() ||
            entityId.includes(key) || key.includes(entityId)) {
          if (Array.isArray(instances)) {
            instances.forEach(inst => {
              results.push({ ...inst, _entityType: key, _dataType: inst.testCategory || inst.dataType || 'typical' });
            });
          } else if (typeof instances === 'object') {
            results.push({ ...instances, _entityType: key, _dataType: instances.testCategory || 'typical' });
          }
        }
      }
    }

    // If source is an array, filter by entityType
    if (Array.isArray(source)) {
      source.forEach(inst => {
        const instType = inst.entityType || inst['@type'] || inst.type || '';
        if (instType === entityId || instType.includes(entityId) || entityId.includes(instType)) {
          results.push({ ...inst, _dataType: inst.testCategory || inst.dataType || 'typical' });
        }
      });
    }
  }

  // Also check 60-20-10-10 distribution structure
  const distributions = ['typical', 'edge', 'boundary', 'invalid'];
  for (const dist of distributions) {
    const distData = currentData[dist] || currentData.testData?.[dist];
    if (distData && typeof distData === 'object') {
      for (const [key, instances] of Object.entries(distData)) {
        if (key === entityId || key.toLowerCase() === entityId.toLowerCase()) {
          if (Array.isArray(instances)) {
            instances.forEach(inst => results.push({ ...inst, _entityType: key, _dataType: dist }));
          }
        }
      }
    }
  }

  return results.slice(0, 10); // Limit to 10 instances for display
}

function navigateToNode(nodeId) {
  if (!network || !lastParsed) return;

  // Find the node
  const node = lastParsed.nodes.find(n => n.id === nodeId);
  if (!node) return;

  // Focus on the node in the graph
  network.selectNodes([nodeId]);
  network.focus(nodeId, { scale: 1.5, animation: true });

  // Update sidebar
  showNodeDetails(node);
}

function switchTab(tabName) {
  // Update tab buttons
  document.querySelectorAll('.sidebar-tab').forEach(btn => {
    btn.classList.toggle('active', btn.textContent.toLowerCase() === tabName);
  });

  // Update tab content
  ['details', 'connections', 'schema', 'data'].forEach(name => {
    const el = document.getElementById('tab-' + name);
    if (el) el.style.display = name === tabName ? 'block' : 'none';
  });
}

function field(label, value) {
  return `<div class="field"><div class="field-label">${label}</div><div class="field-value">${value}</div></div>`;
}

function buildLegend(nodes) {
  const types = [...new Set(nodes.map(n => n.entityType))];
  const legend = document.getElementById('legend');
  legend.style.display = 'block';
  legend.innerHTML = types.map(t =>
    `<div class="legend-item"><div class="legend-dot" style="background:${TYPE_COLORS[t] || TYPE_COLORS.default}"></div>${t}</div>`
  ).join('');
}

function togglePhysics() {
  physicsEnabled = !physicsEnabled;
  document.getElementById('btn-physics').classList.toggle('active');
  if (network) network.setOptions({ physics: { enabled: physicsEnabled } });
}

function changeLayout() {
  const layout = document.getElementById('layout-select').value;
  if (!network) return;
  const opts = { layout: {} };
  if (layout === 'hierarchical') {
    opts.layout = { hierarchical: { direction: 'UD', sortMethod: 'hubsize', levelSeparation: 120 } };
    opts.physics = { enabled: false };
  } else if (layout === 'circular') {
    opts.physics = { enabled: true, barnesHut: { gravitationalConstant: -1000, centralGravity: 0.8, springLength: 100 } };
    setTimeout(() => { if (network) network.setOptions({ physics: { enabled: false } }); }, 2000);
  } else {
    opts.physics = { enabled: physicsEnabled };
  }
  network.setOptions(opts);
}

function fitGraph() {
  if (network) network.fit({ animation: true });
}

function exportPNG() {
  if (!network) return;
  const canvas = document.querySelector('#network canvas');
  if (canvas) {
    const link = document.createElement('a');
    link.download = 'ontology-graph.png';
    link.href = canvas.toDataURL('image/png');
    link.click();
  }
}

function toggleSidebar() {
  document.getElementById('sidebar').classList.toggle('open');
}

// Load supplementary test data file to merge with current ontology
function loadTestDataFile() {
  if (!currentData) {
    alert('Load an ontology first, then add test data.');
    return;
  }

  const input = document.createElement('input');
  input.type = 'file';
  input.accept = '.json';
  input.onchange = function(e) {
    const file = e.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = function(ev) {
      try {
        const testData = JSON.parse(ev.target.result);

        // Merge test data into currentData
        if (testData.testData) {
          currentData.testData = { ...currentData.testData, ...testData.testData };
        } else if (testData.instances || testData.sampleData) {
          currentData.testData = testData.instances || testData.sampleData;
        } else if (Array.isArray(testData)) {
          currentData.testData = currentData.testData || {};
          testData.forEach(inst => {
            const entityType = inst.entityType || inst['@type'] || 'unknown';
            if (!currentData.testData[entityType]) currentData.testData[entityType] = [];
            currentData.testData[entityType].push(inst);
          });
        } else {
          // Assume the entire object is test data organized by entity
          currentData.testData = { ...currentData.testData, ...testData };
        }

        // If a node is selected, refresh the data tab
        if (currentNodeId) {
          renderDataTab(currentNodeId);
        }

        alert('Test data loaded successfully! Click on entities to see their data in the Data tab.');
      } catch (err) {
        alert('Failed to parse test data: ' + err.message);
      }
    };
    reader.readAsText(file);
  };
  input.click();
}

function toggleAudit() {
  document.getElementById('audit-panel').classList.toggle('open');
}

// --- GitHub API integration ---
function loadFromGitHub() {
  let pat = sessionStorage.getItem('gh_pat');
  if (!pat) {
    pat = prompt('Enter GitHub Personal Access Token (stored in session only):');
    if (!pat) return;
    sessionStorage.setItem('gh_pat', pat);
  }
  const path = prompt('Enter repo path: owner/repo/path/to/file.json\nExample: ajrmooreuk/PF-Core-BAIV/PBS/ONTOLOGIES/my-ontology.json');
  if (!path) return;

  const parts = path.split('/');
  if (parts.length < 3) { alert('Format: owner/repo/path/to/file.json'); return; }
  const owner = parts[0];
  const repo = parts[1];
  const filePath = parts.slice(2).join('/');
  const url = `https://api.github.com/repos/${owner}/${repo}/contents/${filePath}`;

  document.getElementById('file-name').textContent = `Loading ${filePath}...`;
  fetch(url, { headers: { 'Authorization': `token ${pat}`, 'Accept': 'application/vnd.github.v3.raw' } })
    .then(res => {
      if (!res.ok) throw new Error(`GitHub API ${res.status}: ${res.statusText}`);
      return res.json();
    })
    .then(data => {
      currentData = data;
      document.getElementById('file-name').textContent = filePath;
      const parsed = parseOntology(data, filePath.split('/').pop());
      if (parsed.nodes.length === 0) {
        alert('No nodes parsed. Keys: ' + Object.keys(data).join(', '));
        return;
      }
      renderGraph(parsed);
      dropZone.classList.add('hidden');
    })
    .catch(err => {
      if (err.message.includes('401')) { sessionStorage.removeItem('gh_pat'); }
      alert('GitHub load failed: ' + err.message);
      document.getElementById('file-name').textContent = '';
    });
}
</script>
</body>
</html>
