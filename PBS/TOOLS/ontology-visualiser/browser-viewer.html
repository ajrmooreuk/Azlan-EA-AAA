<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>OAA Ontology Visualiser</title>
<script src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { font-family: 'Segoe UI', system-ui, sans-serif; background: #0f1117; color: #e0e0e0; height: 100vh; display: flex; flex-direction: column; }
  header { background: #1a1d27; padding: 12px 24px; display: flex; align-items: center; gap: 16px; border-bottom: 1px solid #2a2d37; }
  header h1 { font-size: 16px; font-weight: 600; color: #9dfff5; }
  header .stats { font-size: 13px; color: #888; margin-left: auto; }
  .toolbar { background: #1a1d27; padding: 8px 24px; display: flex; gap: 8px; border-bottom: 1px solid #2a2d37; }
  .toolbar button, .toolbar label { background: #2a2d37; border: 1px solid #3a3d47; color: #ccc; padding: 6px 14px; border-radius: 6px; cursor: pointer; font-size: 13px; }
  .toolbar button:hover, .toolbar label:hover { background: #3a3d47; color: #fff; }
  .toolbar button.active { background: #017c75; border-color: #017c75; color: #fff; }
  .toolbar input[type="file"] { display: none; }
  .toolbar select { background: #2a2d37; border: 1px solid #3a3d47; color: #ccc; padding: 6px 10px; border-radius: 6px; font-size: 13px; }
  #graph-container { flex: 1; position: relative; overflow: hidden; min-height: 0; }
  #network { width: 100%; height: 100%; position: absolute; inset: 0; }
  #drop-zone { position: absolute; inset: 0; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 16px; z-index: 10; }
  #drop-zone.hidden { display: none; }
  #drop-zone .drop-area { border: 2px dashed #3a3d47; border-radius: 16px; padding: 60px 80px; text-align: center; transition: border-color 0.2s; }
  #drop-zone .drop-area.dragover { border-color: #9dfff5; background: rgba(157,255,245,0.05); }
  #drop-zone h2 { font-size: 20px; color: #9dfff5; margin-bottom: 8px; }
  #drop-zone p { color: #888; font-size: 14px; }
  #drop-zone .formats { color: #666; font-size: 12px; margin-top: 12px; }
  .sidebar { position: absolute; right: 0; top: 0; bottom: 0; width: 380px; background: #1a1d27; border-left: 1px solid #2a2d37; padding: 16px; overflow-y: auto; z-index: 5; transform: translateX(100%); transition: transform 0.2s; }
  .sidebar.open { transform: translateX(0); }
  .sidebar h3 { font-size: 14px; color: #9dfff5; margin-bottom: 12px; }
  .sidebar .field { margin-bottom: 10px; }
  .sidebar .field-label { font-size: 11px; color: #888; text-transform: uppercase; letter-spacing: 0.5px; }
  .sidebar .field-value { font-size: 13px; color: #e0e0e0; margin-top: 2px; word-break: break-word; }
  .sidebar .close-btn { position: absolute; top: 12px; right: 12px; background: none; border: none; color: #888; cursor: pointer; font-size: 18px; }
  .sidebar-tabs { display: flex; gap: 4px; margin-bottom: 12px; border-bottom: 1px solid #2a2d37; padding-bottom: 8px; }
  .sidebar-tab { background: none; border: none; color: #888; padding: 6px 12px; cursor: pointer; font-size: 12px; border-radius: 4px; }
  .sidebar-tab:hover { color: #ccc; background: #2a2d37; }
  .sidebar-tab.active { color: #9dfff5; background: #2a2d37; }
  .connection-item { display: flex; align-items: center; gap: 8px; padding: 6px 8px; border-radius: 4px; cursor: pointer; font-size: 12px; margin-bottom: 4px; background: #22252f; }
  .connection-item:hover { background: #2a2d37; }
  .connection-arrow { color: #666; font-size: 14px; }
  .connection-label { color: #9dfff5; font-size: 11px; flex-shrink: 0; }
  .connection-node { color: #e0e0e0; }
  .conn-section { margin-bottom: 12px; }
  .conn-section h4 { font-size: 11px; color: #888; text-transform: uppercase; margin-bottom: 6px; }
  .prop-row { display: flex; justify-content: space-between; align-items: flex-start; padding: 6px 8px; background: #22252f; border-radius: 4px; margin-bottom: 4px; font-size: 12px; }
  .prop-name { color: #e0e0e0; }
  .prop-type { color: #888; font-size: 11px; }
  .prop-required { color: #FF9800; font-size: 10px; margin-left: 4px; }
  .data-instance { background: #22252f; border-radius: 6px; padding: 10px; margin-bottom: 8px; font-size: 12px; }
  .data-instance-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; padding-bottom: 6px; border-bottom: 1px solid #2a2d37; }
  .data-instance-id { color: #9dfff5; font-weight: 500; }
  .data-instance-type { font-size: 10px; padding: 2px 6px; border-radius: 8px; }
  .data-instance-type.typical { background: #166534; color: #86efac; }
  .data-instance-type.edge { background: #1e40af; color: #93c5fd; }
  .data-instance-type.boundary { background: #854d0e; color: #fcd34d; }
  .data-instance-type.invalid { background: #7f1d1d; color: #fca5a5; }
  .data-row { display: flex; gap: 8px; margin-bottom: 4px; }
  .data-key { color: #888; min-width: 80px; }
  .data-value { color: #e0e0e0; word-break: break-all; }
  .no-data { color: #666; font-size: 12px; font-style: italic; padding: 12px; text-align: center; }
  .legend { position: absolute; bottom: 16px; left: 16px; background: #1a1d27; border: 1px solid #2a2d37; border-radius: 8px; padding: 12px; z-index: 5; font-size: 12px; }
  .legend-item { display: flex; align-items: center; gap: 8px; margin-bottom: 4px; }
  .legend-dot { width: 10px; height: 10px; border-radius: 50%; }
  .audit-panel { position: absolute; left: 0; top: 0; bottom: 0; width: 340px; background: #1a1d27; border-right: 1px solid #2a2d37; padding: 16px; overflow-y: auto; z-index: 6; transform: translateX(-100%); transition: transform 0.2s; }
  .audit-panel.open { transform: translateX(0); }
  .audit-panel h3 { font-size: 14px; color: #9dfff5; margin-bottom: 12px; }
  .audit-panel .close-btn { position: absolute; top: 12px; right: 12px; background: none; border: none; color: #888; cursor: pointer; font-size: 18px; }
  .audit-section { margin-bottom: 16px; }
  .audit-section h4 { font-size: 12px; color: #888; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 6px; }
  .audit-item { font-size: 12px; color: #ccc; padding: 4px 8px; border-radius: 4px; cursor: pointer; margin-bottom: 2px; }
  .audit-item:hover { background: #2a2d37; color: #fff; }
  .audit-badge { display: inline-block; background: #2a2d37; border: 1px solid #3a3d47; color: #ccc; padding: 2px 8px; border-radius: 10px; font-size: 11px; margin-left: 6px; }
  .audit-badge.warn { background: #553016; border-color: #834a22; color: #ffb48e; }
  .audit-badge.ok { background: #166534; border-color: #15803d; color: #86efac; }
  .audit-badge.fail { background: #7f1d1d; border-color: #991b1b; color: #fca5a5; }
  /* OAA Compliance Status */
  .compliance-badge { display: inline-flex; align-items: center; gap: 6px; padding: 4px 10px; border-radius: 12px; font-size: 11px; font-weight: 500; margin-left: 12px; cursor: pointer; }
  .compliance-badge.pass { background: rgba(22,101,52,0.3); border: 1px solid #15803d; color: #86efac; }
  .compliance-badge.warn { background: rgba(85,48,22,0.3); border: 1px solid #834a22; color: #ffb48e; }
  .compliance-badge.fail { background: rgba(127,29,29,0.3); border: 1px solid #991b1b; color: #fca5a5; }
  .compliance-badge .dot { width: 6px; height: 6px; border-radius: 50%; }
  .compliance-badge.pass .dot { background: #86efac; }
  .compliance-badge.warn .dot { background: #ffb48e; }
  .compliance-badge.fail .dot { background: #fca5a5; }
  .gate-result { padding: 8px 10px; margin-bottom: 6px; border-radius: 6px; font-size: 12px; background: #22252f; border-left: 3px solid #3a3d47; }
  .gate-result.pass { border-left-color: #15803d; }
  .gate-result.warn { border-left-color: #834a22; }
  .gate-result.fail { border-left-color: #991b1b; }
  .gate-result .gate-name { font-weight: 500; color: #e0e0e0; margin-bottom: 4px; }
  .gate-result .gate-detail { font-size: 11px; color: #888; }
  .gate-result .gate-items { font-size: 11px; color: #888; margin-top: 4px; padding-left: 12px; }
  /* OAA Upgrade Modal */
  .oaa-modal { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.8); z-index: 1000; display: flex; align-items: center; justify-content: center; }
  .oaa-modal-content { background: #1e2128; border-radius: 8px; padding: 24px; max-width: 700px; width: 90%; max-height: 80vh; overflow-y: auto; position: relative; }
  .oaa-modal-content h3 { margin-bottom: 16px; color: #9dfff5; }
  .oaa-modal-content .close-btn { position: absolute; top: 12px; right: 12px; background: none; border: none; color: #888; cursor: pointer; font-size: 18px; }
  .oaa-command { background: #0d0f12; border: 1px solid #3a3d47; border-radius: 6px; padding: 12px; font-family: monospace; font-size: 12px; color: #ccc; white-space: pre-wrap; word-break: break-all; margin: 12px 0; max-height: 200px; overflow-y: auto; }
  .oaa-btn { background: #017c75; border: none; color: #fff; padding: 8px 16px; border-radius: 4px; cursor: pointer; margin-right: 8px; font-size: 13px; }
  .oaa-btn:hover { background: #019d94; }
  .oaa-btn-secondary { background: #2a2d37; border: 1px solid #3a3d47; }
  .oaa-btn-secondary:hover { background: #3a3d47; }
  /* Ontology Library */
  .library-panel { position: absolute; right: 0; top: 0; bottom: 0; width: 420px; background: #1a1d27; border-left: 1px solid #2a2d37; padding: 16px; overflow-y: auto; z-index: 7; transform: translateX(100%); transition: transform 0.2s; }
  .library-panel.open { transform: translateX(0); }
  .library-panel h3 { font-size: 14px; color: #9dfff5; margin-bottom: 12px; }
  .library-panel .close-btn { position: absolute; top: 12px; right: 12px; background: none; border: none; color: #888; cursor: pointer; font-size: 18px; }
  .library-category { margin-bottom: 16px; }
  .library-category h4 { font-size: 12px; color: #888; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 8px; display: flex; align-items: center; gap: 6px; cursor: pointer; }
  .library-category h4:before { content: 'üìÅ'; font-size: 14px; }
  .library-item { background: #22252f; border-radius: 6px; padding: 10px 12px; margin-bottom: 6px; cursor: pointer; transition: background 0.15s; }
  .library-item:hover { background: #2a2d37; }
  .library-item-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px; }
  .library-item-name { color: #e0e0e0; font-weight: 500; font-size: 13px; }
  .library-item-version { font-size: 11px; padding: 2px 6px; border-radius: 8px; background: #017c75; color: #fff; }
  .library-item-meta { font-size: 11px; color: #666; display: flex; gap: 12px; }
  .library-item-actions { display: flex; gap: 6px; margin-top: 8px; }
  .library-item-actions button { font-size: 11px; padding: 4px 8px; }
  .library-empty { color: #666; font-size: 12px; font-style: italic; padding: 16px; text-align: center; }
  .library-input { width: 100%; background: #22252f; border: 1px solid #3a3d47; border-radius: 4px; padding: 8px 10px; color: #e0e0e0; font-size: 13px; margin-bottom: 12px; }
  .library-input:focus { outline: none; border-color: #017c75; }
  .library-select { width: 100%; background: #22252f; border: 1px solid #3a3d47; border-radius: 4px; padding: 8px 10px; color: #e0e0e0; font-size: 13px; margin-bottom: 12px; }
  .library-form-group { margin-bottom: 12px; }
  .library-form-group label { display: block; font-size: 11px; color: #888; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 4px; }
  .version-history { max-height: 200px; overflow-y: auto; }
  .version-item { display: flex; justify-content: space-between; align-items: center; padding: 8px 10px; background: #22252f; border-radius: 4px; margin-bottom: 4px; font-size: 12px; }
  .version-item:hover { background: #2a2d37; }
  .version-item-info { color: #ccc; }
  .version-item-date { color: #666; font-size: 11px; }
  .save-success { background: rgba(22,101,52,0.3); border: 1px solid #15803d; color: #86efac; padding: 10px 12px; border-radius: 6px; margin-bottom: 12px; font-size: 12px; }
</style>
</head>
<body>

<header>
  <h1>OAA Ontology Visualiser</h1>
  <span id="file-name" style="font-size:13px; color:#666;"></span>
  <span id="compliance-status" style="display:none;" class="compliance-badge" onclick="toggleAudit()" title="Click to view OAA v6.1.0 compliance report">
    <span class="dot"></span>
    <span id="compliance-text">OAA v6.1.0</span>
  </span>
  <span class="stats" id="stats"></span>
</header>

<div class="toolbar">
  <label for="file-input">Open JSON File</label>
  <input type="file" id="file-input" accept=".json,.jsonld">
  <button id="btn-physics" class="active" onclick="togglePhysics()">Physics</button>
  <select id="layout-select" onchange="changeLayout()">
    <option value="physics">Force-directed</option>
    <option value="hierarchical">Hierarchical</option>
    <option value="circular">Circular</option>
  </select>
  <button onclick="fitGraph()">Fit View</button>
  <button onclick="resetGraph()">Reset</button>
  <button onclick="exportPNG()">Export PNG</button>
  <button id="btn-sidebar" onclick="toggleSidebar()">Details</button>
  <button id="btn-audit" onclick="toggleAudit()">OAA Audit</button>
  <button id="btn-run-oaa" onclick="runOAAUpgrade()" style="display:none;" title="Generate Claude Code command to upgrade this ontology">Upgrade with OAA v6</button>
  <button id="btn-save-library" onclick="showSaveToLibrary()" style="display:none;" title="Save compliant ontology to library">Save to Library</button>
  <span style="border-left:1px solid #3a3d47; height:24px;"></span>
  <button onclick="toggleLibrary()">üìö Library</button>
  <button onclick="loadFromGitHub()">Load from GitHub</button>
  <button onclick="loadTestDataFile()">+ Test Data</button>
</div>

<div id="graph-container">
  <div id="drop-zone">
    <div class="drop-area" id="drop-area">
      <h2>Drop JSON Ontology Here</h2>
      <p>or click "Open JSON File" above</p>
      <div class="formats">Supports: OAA v6.1.0 (hasDefinedTerm), JSON-LD, UniRegistry, Registry Entry, Agent Registry<br>Validates against OAA v6.1.0 compliance gates (G1-G6)<br>Or use "Load from GitHub" to fetch from a private repo</div>
    </div>
  </div>
  <div id="network"></div>
  <div class="sidebar" id="sidebar">
    <button class="close-btn" onclick="toggleSidebar()">&times;</button>
    <h3 id="sidebar-title">Node Details</h3>
    <div class="sidebar-tabs" id="sidebar-tabs">
      <button class="sidebar-tab active" onclick="switchTab('details')">Details</button>
      <button class="sidebar-tab" onclick="switchTab('connections')">Connections</button>
      <button class="sidebar-tab" onclick="switchTab('schema')">Schema</button>
      <button class="sidebar-tab" onclick="switchTab('data')">Data</button>
    </div>
    <div id="tab-details" class="tab-content"><p style="color:#666">Click a node to see details</p></div>
    <div id="tab-connections" class="tab-content" style="display:none;"></div>
    <div id="tab-schema" class="tab-content" style="display:none;"></div>
    <div id="tab-data" class="tab-content" style="display:none;"></div>
  </div>
  <div class="legend" id="legend" style="display:none;"></div>
  <div class="audit-panel" id="audit-panel">
    <button class="close-btn" onclick="toggleAudit()">&times;</button>
    <h3>OAA v6.1.0 Compliance</h3>
    <div id="oaa-compliance-content"><p style="color:#666">Load a graph to see compliance report</p></div>
    <h3 style="margin-top:16px;">Graph Audit</h3>
    <div id="audit-content"><p style="color:#666">Load a graph to see audit results</p></div>
  </div>
</div>

<!-- OAA Upgrade Modal -->
<div id="oaa-modal" class="oaa-modal" style="display:none;">
  <div class="oaa-modal-content">
    <button class="close-btn" onclick="closeOAAModal()">&times;</button>
    <h3>Run OAA v6.1.0 Upgrade</h3>
    <div id="oaa-modal-body"></div>
  </div>
</div>

<!-- Save to Library Modal -->
<div id="save-library-modal" class="oaa-modal" style="display:none;">
  <div class="oaa-modal-content" style="max-width:500px;">
    <button class="close-btn" onclick="closeSaveLibraryModal()">&times;</button>
    <h3>Save to Ontology Library</h3>
    <div id="save-library-body"></div>
  </div>
</div>

<!-- Ontology Library Panel -->
<div class="library-panel" id="library-panel">
  <button class="close-btn" onclick="toggleLibrary()">&times;</button>
  <h3>üìö Ontology Library</h3>
  <div style="margin-bottom:12px; display:flex; gap:8px;">
    <button class="oaa-btn oaa-btn-secondary" onclick="exportLibrary()" style="font-size:11px; padding:6px 10px;">Export</button>
    <button class="oaa-btn oaa-btn-secondary" onclick="importLibrary()" style="font-size:11px; padding:6px 10px;">Import</button>
  </div>
  <div id="library-content"><p class="library-empty">Loading library...</p></div>
</div>

<script>
let network = null;
let physicsEnabled = true;
let currentData = null;
let lastAudit = null;
let lastParsed = null;
let currentNodeId = null;

const TYPE_COLORS = {
  'class': '#4CAF50', 'core': '#4CAF50', 'framework': '#2196F3',
  'supporting': '#FF9800', 'agent': '#E91E63', 'external': '#9E9E9E',
  'layer': '#00BCD4', 'concept': '#9C27B0', 'default': '#017c75'
};

const EDGE_COLORS = {
  'subClassOf': '#888', 'inheritance': '#888', 'relationship': '#4CAF50',
  'binding': '#FF9800', 'value_chain': '#2196F3', 'default': '#555'
};

// --- File input & drag-drop ---
document.getElementById('file-input').addEventListener('change', function(e) {
  const file = e.target.files[0];
  if (file) loadFile(file);
});

const dropArea = document.getElementById('drop-area');
const dropZone = document.getElementById('drop-zone');

['dragenter', 'dragover'].forEach(evt => {
  dropArea.addEventListener(evt, e => { e.preventDefault(); dropArea.classList.add('dragover'); });
});
['dragleave', 'drop'].forEach(evt => {
  dropArea.addEventListener(evt, e => { e.preventDefault(); dropArea.classList.remove('dragover'); });
});
dropArea.addEventListener('drop', e => {
  const file = e.dataTransfer.files[0];
  if (file) loadFile(file);
});

function loadFile(file) {
  document.getElementById('file-name').textContent = file.name;
  const reader = new FileReader();
  reader.onload = function(e) {
    try {
      const data = JSON.parse(e.target.result);
      currentData = data;
      const parsed = parseOntology(data, file.name);
      if (parsed.nodes.length === 0) {
        alert('No nodes parsed from this file. Keys found: ' + Object.keys(data).join(', '));
        return;
      }
      renderGraph(parsed);
      dropZone.classList.add('hidden');
    } catch (err) {
      alert('Failed to parse JSON: ' + err.message);
    }
  };
  reader.readAsText(file);
}

// --- Fix 1: Unified format detection ---
function detectFormat(data) {
  if (data.agents && Array.isArray(data.agents)) return 'agent-registry';
  if (data.registryEntry) return 'registry-entry';
  if (data.ontologyDefinition) return 'uni-registry';
  if (data.entities && Array.isArray(data.entities)) return 'pf-ontology';
  if (data.hasDefinedTerm && Array.isArray(data.hasDefinedTerm)) return 'jsonld-definedterm';
  if (data.classes || data['@graph']) return 'jsonld';
  return 'generic';
}

function parseOntology(data, source) {
  const nodes = [];
  const edges = [];
  const seen = new Set();
  const diagnostics = { format: '', stubNodes: [], orphanEdges: [] };

  function addNode(id, label, type, description, properties) {
    if (seen.has(id)) return;
    seen.add(id);
    nodes.push({ id, label: label || id, entityType: type || 'default', description: description || '', properties: properties || {} });
  }

  function addEdge(from, to, label, type) {
    edges.push({ from, to, label: label || '', edgeType: type || 'relationship' });
  }

  const format = detectFormat(data);
  diagnostics.format = format;

  // --- Parse by detected format (mutually exclusive) ---
  if (format === 'agent-registry') {
    data.agents.forEach(agent => {
      addNode(agent.id, agent.name || agent.id, 'agent', agent.purpose || agent.description, agent);
      if (agent.dependencies) agent.dependencies.forEach(dep => addEdge(agent.id, dep, 'depends on', 'binding'));
      if (agent.layer) {
        const layerId = 'layer:' + agent.layer;
        addNode(layerId, agent.layer, 'layer', 'Agent layer');
        addEdge(agent.id, layerId, 'in layer', 'binding');
      }
    });
  }

  else if (format === 'registry-entry') {
    const re = data.registryEntry;
    const name = re.name || re.ontologyName || source;
    addNode('root', name, 'core', re.description || re.summary || '');
    if (re.summary && re.summary.entities) {
      re.summary.entities.forEach(ent => {
        const id = ent.id || ent.name;
        addNode(id, ent.name || id, ent.entityType || 'class', ent.description || '', ent);
        addEdge('root', id, 'contains', 'relationship');
      });
    }
    if (re.summary && re.summary.relationships) {
      re.summary.relationships.forEach(rel => {
        if (rel.source && rel.target) addEdge(rel.source, rel.target, rel.label || rel.name || '', 'relationship');
      });
    }
  }

  else if (format === 'uni-registry') {
    const od = data.ontologyDefinition;
    const ontName = (data.registryMetadata && data.registryMetadata.name) || od.name || source;
    const ontDesc = (data.registryMetadata && data.registryMetadata.description) || od.description || '';

    const graph = od['@graph'] || [];
    graph.forEach(cls => {
      const id = cls['@id'] || cls.id;
      const label = cls['rdfs:label'] || cls.name || cls.label || id;
      const desc = cls['rdfs:comment'] || cls.description || '';
      if (id) addNode(id, label, 'class', desc, cls);
      const parent = cls['rdfs:subClassOf'];
      if (parent) {
        const parentId = typeof parent === 'object' ? (parent['@id'] || parent.id) : parent;
        if (parentId) {
          if (!seen.has(parentId)) addNode(parentId, parentId.replace(/.*[:#]/, ''), 'external', 'schema.org / base type');
          addEdge(id, parentId, 'subClassOf', 'inheritance');
        }
      }
    });

    if (od.entities) {
      od.entities.forEach(ent => {
        const id = ent['@id'] || ent.id || ent.name;
        addNode(id, ent.name || ent['rdfs:label'] || id, ent.entityType || 'class', ent.description || '', ent);
      });
    }

    if (od.relationships) {
      od.relationships.forEach(rel => {
        const label = rel['rdfs:label'] || rel.name || rel.label || '';
        let domain = rel['rdfs:domain'] || rel.source;
        let range = rel['rdfs:range'] || rel.target;
        if (typeof domain !== 'string') domain = null;
        if (typeof range !== 'string') range = null;
        if (domain && range) {
          if (!seen.has(domain)) addNode(domain, domain.replace(/.*[:#]/, ''), 'external', '');
          if (!seen.has(range)) addNode(range, range.replace(/.*[:#]/, ''), 'external', '');
          addEdge(domain, range, label, 'relationship');
        }
        const domains = rel.domainIncludes || rel['oaa:domainIncludes'];
        const ranges = rel.rangeIncludes || rel['oaa:rangeIncludes'];
        if (domains && ranges) {
          (Array.isArray(domains) ? domains : [domains]).forEach(d => {
            (Array.isArray(ranges) ? ranges : [ranges]).forEach(r => {
              if (!seen.has(d)) addNode(d, d.replace(/.*[:#]/, ''), 'external', '');
              if (!seen.has(r)) addNode(r, r.replace(/.*[:#]/, ''), 'external', '');
              addEdge(d, r, label, 'relationship');
            });
          });
        }
      });
    }

    if (ontName && nodes.length > 0) {
      addNode(data['@id'] || 'ont:root', ontName, 'core', ontDesc);
    }
  }

  else if (format === 'pf-ontology') {
    const ontName = (data.metadata && data.metadata.name) || data.name || source;
    data.entities.forEach(ent => {
      const id = ent['@id'] || ent.id || ent.name;
      const label = ent.name || ent.label || ent['rdfs:label'] || id;
      const desc = ent.description || ent['rdfs:comment'] || '';
      const type = ent.entityType || (ent['@type'] || '').replace(/.*:/, '') || 'class';
      if (id) addNode(id, label, type.toLowerCase(), desc, ent);
      // Handle schemaOrgBase inheritance
      if (ent.schemaOrgBase) {
        addNode(ent.schemaOrgBase, ent.schemaOrgBase.replace('schema:', ''), 'external', 'schema.org type');
        addEdge(id, ent.schemaOrgBase, 'extends', 'inheritance');
      }
      // Handle rdfs:subClassOf inheritance
      const subClassOf = ent['rdfs:subClassOf'] || ent.subClassOf;
      if (subClassOf) {
        const parentId = typeof subClassOf === 'object' ? (subClassOf['@id'] || subClassOf.id) : subClassOf;
        if (parentId) {
          if (!seen.has(parentId)) addNode(parentId, parentId.replace(/.*[:#]/, ''), 'external', 'Parent class');
          addEdge(id, parentId, 'subClassOf', 'inheritance');
        }
      }
    });

    if (data.relationships && Array.isArray(data.relationships)) {
      data.relationships.forEach(rel => {
        const label = rel.name || rel.label || rel['@id'] || rel['rdfs:label'] || '';
        const domains = rel.domainIncludes || rel['oaa:domainIncludes'] || (rel.domain ? [rel.domain] : []);
        const ranges = rel.rangeIncludes || rel['oaa:rangeIncludes'] || (rel.range ? [rel.range] : []);
        (Array.isArray(domains) ? domains : [domains]).forEach(d => {
          (Array.isArray(ranges) ? ranges : [ranges]).forEach(r => {
            if (!seen.has(d)) addNode(d, d.replace(/.*:/, ''), 'external', '');
            if (!seen.has(r)) addNode(r, r.replace(/.*:/, ''), 'external', '');
            addEdge(d, r, label, rel.linkedOntology ? 'binding' : 'relationship');
          });
        });
      });
    }

    if (data.metadata && data.metadata.dependencies) {
      const rootId = data['@id'] || 'root';
      addNode(rootId, ontName, 'core', data.metadata.description || '');
      data.metadata.dependencies.forEach(dep => {
        addNode(dep, dep.replace(/.*:/, ''), 'external', 'Dependency');
        addEdge(rootId, dep, 'depends on', 'binding');
      });
    }
  }

  else if (format === 'jsonld-definedterm') {
    // OAA v6.1.0 / EFS-style JSON-LD with hasDefinedTerm array
    const ontName = data.name || data['rdfs:label'] || data['@id'] || source;
    const ontDesc = data.description || data['rdfs:comment'] || '';

    // Parse entities from hasDefinedTerm
    data.hasDefinedTerm.forEach(term => {
      const id = term['@id'] || term.name;
      const label = term.name || term['rdfs:label'] || id;
      const desc = term.description || term['rdfs:comment'] || '';
      const termType = term['@type'] || term.type || 'Class';
      const entityType = termType.toLowerCase().includes('property') ? 'supporting' : 'class';

      if (id) addNode(id, label, entityType, desc, term);

      // Handle rdfs:subClassOf (inheritance)
      const parent = term['rdfs:subClassOf'];
      if (parent) {
        const parentId = typeof parent === 'object' ? (parent['@id'] || parent.id) : parent;
        if (parentId) {
          if (!seen.has(parentId)) {
            addNode(parentId, parentId.replace(/.*[:#]/, ''), 'external', 'schema.org / base type');
          }
          addEdge(id, parentId, 'subClassOf', 'inheritance');
        }
      }

      // Handle schema:domainIncludes for properties
      const domains = term['schema:domainIncludes'] || term['oaa:domainIncludes'] || term.domainIncludes;
      const ranges = term['schema:rangeIncludes'] || term['oaa:rangeIncludes'] || term.rangeIncludes;
      if (domains || ranges) {
        const domainList = Array.isArray(domains) ? domains : (domains ? [domains] : []);
        const rangeList = Array.isArray(ranges) ? ranges : (ranges ? [ranges] : []);

        domainList.forEach(d => {
          const domainId = typeof d === 'object' ? (d['@id'] || d.id) : d;
          if (domainId) {
            if (!seen.has(domainId)) addNode(domainId, domainId.replace(/.*[:#]/, ''), 'class', '');
            addEdge(domainId, id, 'has property', 'relationship');
          }
        });

        rangeList.forEach(r => {
          const rangeId = typeof r === 'object' ? (r['@id'] || r.id) : r;
          if (rangeId) {
            if (!seen.has(rangeId)) addNode(rangeId, rangeId.replace(/.*[:#]/, ''), 'external', '');
            addEdge(id, rangeId, 'range', 'relationship');
          }
        });
      }
    });

    // Parse explicit relationships if present
    if (data.relationships && Array.isArray(data.relationships)) {
      data.relationships.forEach(rel => {
        const label = rel.name || rel['rdfs:label'] || rel['@id'] || '';
        const domains = rel.domainIncludes || rel['oaa:domainIncludes'] || (rel.domain ? [rel.domain] : []);
        const ranges = rel.rangeIncludes || rel['oaa:rangeIncludes'] || (rel.range ? [rel.range] : []);
        (Array.isArray(domains) ? domains : [domains]).forEach(d => {
          (Array.isArray(ranges) ? ranges : [ranges]).forEach(r => {
            if (d && r) {
              if (!seen.has(d)) addNode(d, d.replace(/.*[:#]/, ''), 'class', '');
              if (!seen.has(r)) addNode(r, r.replace(/.*[:#]/, ''), 'class', '');
              addEdge(d, r, label, 'relationship');
            }
          });
        });
      });
    }

    // Add root node for ontology
    if (ontName && nodes.length > 0) {
      addNode(data['@id'] || 'ont:root', ontName.replace(/.*[:#]/, ''), 'core', ontDesc);
    }
  }

  else if (format === 'jsonld') {
    const classes = data.classes || data['@graph'] || [];
    (Array.isArray(classes) ? classes : []).forEach(cls => {
      const id = cls['@id'] || cls.id || cls.name;
      const label = cls['rdfs:label'] || cls.label || cls.name || id;
      const desc = cls['rdfs:comment'] || cls.description || '';
      const type = cls.entityType || cls.type || 'class';
      if (id) addNode(id, label, type, desc, cls.properties || cls);
      const parent = cls['rdfs:subClassOf'] || cls.subClassOf || cls.parentClass;
      if (parent) {
        const parentId = typeof parent === 'object' ? (parent['@id'] || parent.id) : parent;
        if (parentId) { addNode(parentId, parentId, 'class', ''); addEdge(id, parentId, 'subClassOf', 'inheritance'); }
      }
    });
    const rels = data.relationships || data.properties || [];
    (Array.isArray(rels) ? rels : []).forEach(rel => {
      const src = rel.source || rel.domain || rel.from;
      const tgt = rel.target || rel.range || rel.to;
      const label = rel.label || rel.name || rel['rdfs:label'] || '';
      if (src && tgt) addEdge(src, tgt, label, 'relationship');
    });
  }

  else { // generic
    addNode('root', source, 'core', 'Root');
    for (const [key, val] of Object.entries(data)) {
      if (key.startsWith('@') || key.startsWith('$')) continue;
      if (typeof val === 'object' && val !== null && !Array.isArray(val)) {
        addNode(key, val.name || val.label || key, val.entityType || val.type || 'concept', val.description || '');
        addEdge('root', key, 'contains', 'relationship');
        for (const [k2, v2] of Object.entries(val)) {
          if (typeof v2 === 'object' && v2 !== null && !Array.isArray(v2) && !k2.startsWith('@')) {
            const childId = key + '.' + k2;
            addNode(childId, v2.name || v2.label || k2, v2.entityType || 'supporting', v2.description || '');
            addEdge(key, childId, k2, 'relationship');
          }
        }
      } else if (Array.isArray(val)) {
        val.forEach((item, i) => {
          if (typeof item === 'object' && item !== null) {
            const id = item.id || item.name || key + '_' + i;
            addNode(id, item.name || item.label || id, item.entityType || item.type || 'class', item.description || '', item);
            addEdge('root', id, key, 'relationship');
          }
        });
      }
    }
  }

  // --- Fix 2: Edge validation ‚Äî ensure all edge endpoints exist ---
  edges.forEach(e => {
    if (!seen.has(e.from)) {
      addNode(e.from, e.from.replace(/.*[:#]/, ''), 'external', 'Auto-created stub (missing reference)');
      diagnostics.stubNodes.push(e.from);
    }
    if (!seen.has(e.to)) {
      addNode(e.to, e.to.replace(/.*[:#]/, ''), 'external', 'Auto-created stub (missing reference)');
      diagnostics.stubNodes.push(e.to);
    }
  });

  return { nodes, edges, name: data.name || data.ontologyName || source, diagnostics };
}

// --- Fix 4 & 5: Graph audit ---
function auditGraph(parsed) {
  const nodeIds = new Set(parsed.nodes.map(n => n.id));
  const edgeSet = new Map(); // nodeId -> { in: count, out: count }
  nodeIds.forEach(id => edgeSet.set(id, { in: 0, out: 0 }));
  parsed.edges.forEach(e => {
    if (edgeSet.has(e.from)) edgeSet.get(e.from).out++;
    if (edgeSet.has(e.to)) edgeSet.get(e.to).in++;
  });

  // Isolated nodes (zero edges)
  const isolated = parsed.nodes.filter(n => {
    const counts = edgeSet.get(n.id);
    return counts && counts.in === 0 && counts.out === 0;
  });

  // Connected components via BFS
  const adj = new Map();
  nodeIds.forEach(id => adj.set(id, []));
  parsed.edges.forEach(e => {
    if (adj.has(e.from)) adj.get(e.from).push(e.to);
    if (adj.has(e.to)) adj.get(e.to).push(e.from);
  });
  const visited = new Set();
  const components = [];
  nodeIds.forEach(id => {
    if (visited.has(id)) return;
    const component = [];
    const queue = [id];
    while (queue.length > 0) {
      const cur = queue.shift();
      if (visited.has(cur)) continue;
      visited.add(cur);
      component.push(cur);
      (adj.get(cur) || []).forEach(nb => { if (!visited.has(nb)) queue.push(nb); });
    }
    components.push(component);
  });
  components.sort((a, b) => b.length - a.length);

  return {
    format: parsed.diagnostics.format,
    totalNodes: parsed.nodes.length,
    totalEdges: parsed.edges.length,
    isolated,
    components,
    stubNodes: parsed.diagnostics.stubNodes,
    mainComponentSize: components.length > 0 ? components[0].length : 0,
    disconnectedCount: components.length - 1
  };
}

// ========================================
// OAA v6.1.0 VALIDATION GATES
// ========================================

function validateOAAv5(data, parsed) {
  const gates = [];

  // === CORE GATES (G1-G4) - Required for compliance ===

  // GATE 1: Schema Structure
  gates.push(validateG1SchemaStructure(data));

  // GATE 2: Relationship Cardinality
  gates.push(validateG2RelationshipCardinality(data));

  // GATE 2B: Entity Connectivity (sub-gate of G2)
  gates.push(validateG2BEntityConnectivity(parsed));

  // GATE 2C: Graph Connectivity (sub-gate of G2)
  gates.push(validateG2CGraphConnectivity(parsed));

  // GATE 3: Business Rules (IF-THEN format)
  gates.push(validateG3BusinessRules(data));

  // GATE 4: Semantic Consistency
  gates.push(validateG4SemanticConsistency(data, parsed));

  // === ADVISORY GATES (G5-G6) - Recommendations only ===

  // GATE 5: Completeness (advisory)
  const g5 = validateG5Completeness(data, parsed);
  g5.advisory = true;
  gates.push(g5);

  // GATE 6: UniRegistry Format (advisory, if applicable)
  const g6 = validateG6UniRegistry(data);
  g6.advisory = true;
  gates.push(g6);

  // Calculate overall status (only core gates G1-G4 affect pass/fail)
  const coreGates = gates.filter(g => !g.advisory && !g.skipped);
  const failCount = coreGates.filter(g => g.status === 'fail').length;
  const warnCount = coreGates.filter(g => g.status === 'warn').length;
  const passCount = coreGates.filter(g => g.status === 'pass').length;

  let overall = 'pass';
  if (failCount > 0) overall = 'fail';
  else if (warnCount > 0) overall = 'warn';

  return {
    gates,
    overall,
    summary: { pass: passCount, warn: warnCount, fail: failCount, advisory: gates.filter(g => g.advisory).length }
  };
}

// GATE 1: Schema Structure - JSON-LD compliance, required fields
function validateG1SchemaStructure(data) {
  const issues = [];
  const warnings = [];

  // Check for @context (JSON-LD)
  if (!data['@context']) {
    warnings.push('Missing @context (not strict JSON-LD)');
  }

  // Check for @id or identifier
  if (!data['@id'] && !data.id && !data.name) {
    issues.push('Missing ontology identifier (@id, id, or name)');
  }

  // Check for entities/hasDefinedTerm
  const hasEntities = data.entities || data.hasDefinedTerm || data['@graph'] ||
                      (data.ontologyDefinition && (data.ontologyDefinition.entities || data.ontologyDefinition['@graph']));
  if (!hasEntities) {
    issues.push('No entities found (entities, hasDefinedTerm, or @graph)');
  }

  // Check entity structure
  const entities = data.entities || data.hasDefinedTerm || data['@graph'] ||
                   (data.ontologyDefinition && (data.ontologyDefinition.entities || data.ontologyDefinition['@graph'])) || [];
  if (Array.isArray(entities)) {
    entities.forEach((e, i) => {
      if (!e['@id'] && !e.id && !e.name) {
        issues.push(`Entity ${i}: missing identifier`);
      }
    });
  }

  return {
    gate: 'G1: Schema Structure',
    status: issues.length > 0 ? 'fail' : (warnings.length > 0 ? 'warn' : 'pass'),
    issues,
    warnings,
    detail: issues.length === 0 ? 'Valid JSON structure' : `${issues.length} issue(s) found`
  };
}

// GATE 2: Relationship Cardinality - domainIncludes/rangeIncludes format
function validateG2RelationshipCardinality(data) {
  const issues = [];
  const warnings = [];

  // Find relationships
  const relationships = data.relationships ||
                        (data.ontologyDefinition && data.ontologyDefinition.relationships) || [];

  if (relationships.length === 0) {
    warnings.push('No explicit relationships defined');
    return {
      gate: 'G2: Relationship Cardinality',
      status: 'warn',
      issues,
      warnings,
      detail: 'No relationships to validate'
    };
  }

  relationships.forEach((rel, i) => {
    const name = rel.name || rel['@id'] || rel['rdfs:label'] || `Relationship ${i}`;

    // Check for domain
    const hasDomain = rel.domainIncludes || rel.domain || rel.source || rel['rdfs:domain'] || rel['schema:domainIncludes'] || rel['oaa:domainIncludes'];
    if (!hasDomain) {
      issues.push(`${name}: missing domain`);
    }

    // Check for range
    const hasRange = rel.rangeIncludes || rel.range || rel.target || rel['rdfs:range'] || rel['schema:rangeIncludes'] || rel['oaa:rangeIncludes'];
    if (!hasRange) {
      issues.push(`${name}: missing range`);
    }

    // Check cardinality notation
    const cardinality = rel.cardinality || rel['oaa:cardinality'];
    if (cardinality) {
      const cardPattern = /^(0|1|\*|n)(\.\.(0|1|\*|n))?$/i;
      if (!cardPattern.test(cardinality)) {
        warnings.push(`${name}: non-standard cardinality notation "${cardinality}"`);
      }
    }
  });

  return {
    gate: 'G2: Relationship Cardinality',
    status: issues.length > 0 ? 'fail' : (warnings.length > 0 ? 'warn' : 'pass'),
    issues,
    warnings,
    detail: `${relationships.length} relationship(s) checked`
  };
}

// GATE 2B: Entity Connectivity - every entity in at least one relationship
function validateG2BEntityConnectivity(parsed) {
  if (!parsed || !parsed.nodes) {
    return { gate: 'G2B: Entity Connectivity', status: 'warn', issues: [], warnings: ['No parsed data'], detail: 'Cannot validate' };
  }

  const entityIds = new Set(parsed.nodes.map(n => n.id));
  const connected = new Set();

  parsed.edges.forEach(e => {
    connected.add(e.from);
    connected.add(e.to);
  });

  // Exclude external/stub nodes from orphan check
  const orphaned = parsed.nodes.filter(n =>
    !connected.has(n.id) && n.entityType !== 'external'
  );

  const nonExternalCount = parsed.nodes.filter(n => n.entityType !== 'external').length;
  const connectedNonExternal = parsed.nodes.filter(n =>
    connected.has(n.id) && n.entityType !== 'external'
  ).length;

  const pct = nonExternalCount > 0 ? Math.round((connectedNonExternal / nonExternalCount) * 100) : 100;

  return {
    gate: 'G2B: Entity Connectivity',
    status: orphaned.length > 0 ? 'fail' : 'pass',
    issues: orphaned.map(n => `${n.label || n.id} (${n.entityType})`),
    warnings: [],
    detail: `${pct}% entities connected (${connectedNonExternal}/${nonExternalCount})`,
    orphaned: orphaned.map(n => n.id)
  };
}

// GATE 2C: Graph Connectivity - single connected component
function validateG2CGraphConnectivity(parsed) {
  if (!parsed || !parsed.nodes) {
    return { gate: 'G2C: Graph Connectivity', status: 'warn', issues: [], warnings: ['No parsed data'], detail: 'Cannot validate' };
  }

  // Build adjacency for non-external nodes only
  const nonExternalNodes = parsed.nodes.filter(n => n.entityType !== 'external');
  const nodeIds = new Set(nonExternalNodes.map(n => n.id));

  if (nodeIds.size === 0) {
    return { gate: 'G2C: Graph Connectivity', status: 'pass', issues: [], warnings: [], detail: 'No domain entities' };
  }

  const adj = new Map();
  nodeIds.forEach(id => adj.set(id, []));

  parsed.edges.forEach(e => {
    if (nodeIds.has(e.from) && nodeIds.has(e.to)) {
      adj.get(e.from).push(e.to);
      adj.get(e.to).push(e.from);
    }
  });

  // BFS to find components
  const visited = new Set();
  const components = [];

  nodeIds.forEach(id => {
    if (visited.has(id)) return;
    const component = [];
    const queue = [id];
    while (queue.length > 0) {
      const cur = queue.shift();
      if (visited.has(cur)) continue;
      visited.add(cur);
      component.push(cur);
      (adj.get(cur) || []).forEach(nb => { if (!visited.has(nb)) queue.push(nb); });
    }
    components.push(component);
  });

  const isConnected = components.length <= 1;

  return {
    gate: 'G2C: Graph Connectivity',
    status: isConnected ? 'pass' : 'warn',
    issues: [],
    warnings: isConnected ? [] : [`${components.length} disconnected clusters`],
    detail: isConnected ? 'Single connected component' : `${components.length} components`,
    components: components.length
  };
}

// GATE 3: Business Rules - IF-THEN format validation
function validateG3BusinessRules(data) {
  const issues = [];
  const warnings = [];

  // Find business rules in various locations
  const businessRules = data.businessRules || data.rules ||
                        (data.ontologyDefinition && data.ontologyDefinition.businessRules) || [];

  if (businessRules.length === 0) {
    // No business rules defined - this is a warning, not failure
    return {
      gate: 'G3: Business Rules',
      status: 'warn',
      issues: [],
      warnings: ['No business rules defined'],
      detail: 'Consider adding IF-THEN business rules'
    };
  }

  // Validate IF-THEN format
  const ifThenPattern = /^IF\s+.+\s+THEN\s+.+$/i;
  const expressionPattern = /^[A-Za-z_][A-Za-z0-9_.]*\s*(==|!=|>|<|>=|<=|&&|\|\||\s+AND\s+|\s+OR\s+)/i;

  let compliantCount = 0;
  businessRules.forEach((rule, i) => {
    const ruleName = rule.name || rule['@id'] || rule.id || `Rule ${i + 1}`;

    // Support OAA v5.0.0 format with separate condition/action fields
    let ruleText = '';
    if (rule.condition && rule.action) {
      // OAA v5.0.0 format: combine condition + action
      ruleText = `${rule.condition} ${rule.action}`;
    } else {
      // Legacy format: single expression field
      ruleText = rule.expression || rule.rule || rule.description || '';
    }

    // Check for IF-THEN format
    if (ifThenPattern.test(ruleText)) {
      compliantCount++;
    } else if (rule.condition && rule.action) {
      // OAA v5.0.0 format present but not matching IF-THEN pattern exactly
      // Check if condition starts with IF and action contains constraint
      if (rule.condition.toUpperCase().startsWith('IF') && rule.action.toUpperCase().includes('MUST')) {
        compliantCount++;
      } else {
        warnings.push(`${ruleName}: condition/action should use IF...THEN format`);
      }
    } else if (expressionPattern.test(ruleText)) {
      // Has a logical expression but not in IF-THEN format
      warnings.push(`${ruleName}: has expression but not IF-THEN format`);
    } else if (ruleText.trim() === '') {
      issues.push(`${ruleName}: empty rule expression`);
    } else {
      warnings.push(`${ruleName}: convert to IF-THEN format`);
    }

    // Check for severity
    if (!rule.severity) {
      warnings.push(`${ruleName}: missing severity (error/warning/info)`);
    }
  });

  const pct = businessRules.length > 0 ? Math.round((compliantCount / businessRules.length) * 100) : 0;

  return {
    gate: 'G3: Business Rules',
    status: issues.length > 0 ? 'fail' : (pct < 80 ? 'warn' : 'pass'),
    issues,
    warnings: warnings.slice(0, 5),
    detail: `${pct}% rules in IF-THEN format (${compliantCount}/${businessRules.length})`
  };
}

// GATE 4: Semantic Consistency - naming conventions, descriptions
function validateG4SemanticConsistency(data, parsed) {
  const issues = [];
  const warnings = [];

  if (!parsed || !parsed.nodes) {
    return { gate: 'G4: Semantic Consistency', status: 'warn', issues: [], warnings: ['No parsed data'], detail: 'Cannot validate' };
  }

  parsed.nodes.forEach(n => {
    if (n.entityType === 'external') return;

    // Check for description
    if (!n.description || n.description.trim() === '') {
      warnings.push(`${n.label}: missing description`);
    }

    // Check naming convention (PascalCase for entities)
    if (n.label && n.entityType !== 'layer') {
      const pascalPattern = /^[A-Z][a-zA-Z0-9]*$/;
      const hasSpaces = /\s/.test(n.label);
      if (!pascalPattern.test(n.label) && !hasSpaces) {
        // Only warn if it's clearly not following any convention
        if (!/^[a-z]/.test(n.label) === false && n.label.includes('_')) {
          warnings.push(`${n.label}: consider PascalCase naming`);
        }
      }
    }
  });

  // Limit warnings shown
  const shownWarnings = warnings.slice(0, 5);
  if (warnings.length > 5) {
    shownWarnings.push(`... and ${warnings.length - 5} more`);
  }

  return {
    gate: 'G4: Semantic Consistency',
    status: issues.length > 0 ? 'fail' : (warnings.length > 0 ? 'warn' : 'pass'),
    issues,
    warnings: shownWarnings,
    detail: warnings.length === 0 ? 'All entities have descriptions' : `${warnings.length} entities missing descriptions`
  };
}

// GATE 5: Completeness - all required fields populated
function validateG5Completeness(data, parsed) {
  const issues = [];
  const warnings = [];

  // Check metadata
  const hasMetadata = data.metadata || data.registryMetadata || data['@context'];
  if (!hasMetadata) {
    warnings.push('No metadata block found');
  } else {
    const meta = data.metadata || data.registryMetadata || {};
    if (!meta.version && !data.version) warnings.push('Missing version');
    if (!meta.author && !meta.creator && !data.author) warnings.push('Missing author/creator');
  }

  // Check entity completeness
  const entities = data.entities || data.hasDefinedTerm ||
                   (data.ontologyDefinition && (data.ontologyDefinition.entities || data.ontologyDefinition['@graph'])) || [];

  let missingType = 0;
  if (Array.isArray(entities)) {
    entities.forEach(e => {
      if (!e['@type'] && !e.type && !e.entityType) missingType++;
    });
  }

  if (missingType > 0) {
    warnings.push(`${missingType} entities missing @type`);
  }

  // Check edge-to-node ratio
  if (parsed && parsed.nodes.length > 0) {
    const nonExternal = parsed.nodes.filter(n => n.entityType !== 'external').length;
    const ratio = nonExternal > 0 ? (parsed.edges.length / nonExternal).toFixed(2) : 0;
    if (ratio < 0.5 && nonExternal > 3) {
      warnings.push(`Low edge-to-node ratio: ${ratio} (recommend ‚â•0.8)`);
    }
  }

  return {
    gate: 'G5: Completeness',
    status: issues.length > 0 ? 'fail' : (warnings.length > 0 ? 'warn' : 'pass'),
    issues,
    warnings,
    detail: issues.length + warnings.length === 0 ? 'All required fields present' : `${warnings.length} recommendation(s)`
  };
}

// GATE 6: UniRegistry Format
function validateG6UniRegistry(data) {
  const issues = [];
  const warnings = [];

  // Check if this looks like a UniRegistry format
  const isUniRegistry = data.ontologyDefinition || data.registryEntry || data.registryMetadata;

  if (!isUniRegistry) {
    return {
      gate: 'G6: UniRegistry Format',
      status: 'pass',
      issues: [],
      warnings: [],
      detail: 'Not UniRegistry format (OK)',
      skipped: true
    };
  }

  // Validate UniRegistry structure
  if (data.ontologyDefinition) {
    const od = data.ontologyDefinition;
    if (!od.name && !od['rdfs:label']) warnings.push('ontologyDefinition missing name');
    if (!od['@graph'] && !od.entities) warnings.push('ontologyDefinition missing @graph or entities');
  }

  if (data.registryMetadata) {
    const rm = data.registryMetadata;
    if (!rm.registryId) warnings.push('registryMetadata missing registryId');
    if (!rm.registeredAt && !rm.createdAt) warnings.push('registryMetadata missing timestamp');
  }

  return {
    gate: 'G6: UniRegistry Format',
    status: issues.length > 0 ? 'fail' : (warnings.length > 0 ? 'warn' : 'pass'),
    issues,
    warnings,
    detail: 'UniRegistry format validated'
  };
}

// Render OAA Compliance Panel
function renderOAACompliancePanel(validation) {
  const el = document.getElementById('oaa-compliance-content');
  let html = '';

  // Overall status
  const statusText = validation.overall === 'pass' ? 'Compliant' :
                     validation.overall === 'warn' ? 'Warnings' : 'Non-Compliant';
  html += `<div style="margin-bottom:12px; padding:10px; border-radius:6px; background:${
    validation.overall === 'pass' ? 'rgba(22,101,52,0.2)' :
    validation.overall === 'warn' ? 'rgba(85,48,22,0.2)' : 'rgba(127,29,29,0.2)'
  };">`;
  html += `<div style="font-weight:600; color:${
    validation.overall === 'pass' ? '#86efac' :
    validation.overall === 'warn' ? '#ffb48e' : '#fca5a5'
  };">${statusText}</div>`;
  html += `<div style="font-size:11px; color:#888; margin-top:4px;">Core gates (G1-G4): ${validation.summary.pass} pass | ${validation.summary.warn} warn | ${validation.summary.fail} fail</div>`;
  html += '</div>';

  // Core gates section
  html += '<div style="margin-bottom:8px; font-size:11px; color:#888; text-transform:uppercase; letter-spacing:0.5px;">Core Gates (Required)</div>';

  // Individual core gates
  validation.gates.forEach(g => {
    if (g.skipped || g.advisory) return; // Skip non-applicable and advisory gates

    html += `<div class="gate-result ${g.status}">`;
    html += `<div class="gate-name">${g.gate} <span class="audit-badge ${g.status}">${g.status.toUpperCase()}</span></div>`;
    html += `<div class="gate-detail">${g.detail}</div>`;

    // Show issues
    if (g.issues && g.issues.length > 0) {
      html += '<div class="gate-items">';
      g.issues.slice(0, 3).forEach(issue => {
        html += `<div style="color:#fca5a5;">‚Ä¢ ${issue}</div>`;
      });
      if (g.issues.length > 3) html += `<div style="color:#888;">... and ${g.issues.length - 3} more</div>`;
      html += '</div>';
    }

    // Show warnings
    if (g.warnings && g.warnings.length > 0) {
      html += '<div class="gate-items">';
      g.warnings.slice(0, 3).forEach(warn => {
        html += `<div style="color:#ffb48e;">‚Ä¢ ${warn}</div>`;
      });
      if (g.warnings.length > 3) html += `<div style="color:#888;">... and ${g.warnings.length - 3} more</div>`;
      html += '</div>';
    }

    html += '</div>';
  });

  // Advisory gates section
  const advisoryGates = validation.gates.filter(g => g.advisory && !g.skipped);
  if (advisoryGates.length > 0) {
    html += '<div style="margin-top:16px; margin-bottom:8px; font-size:11px; color:#888; text-transform:uppercase; letter-spacing:0.5px;">Advisory Gates (Recommendations)</div>';

    advisoryGates.forEach(g => {
      html += `<div class="gate-result ${g.status}" style="opacity:0.7;">`;
      html += `<div class="gate-name">${g.gate} <span style="font-size:10px; color:#666;">ADVISORY</span></div>`;
      html += `<div class="gate-detail">${g.detail}</div>`;

      if (g.warnings && g.warnings.length > 0) {
        html += '<div class="gate-items">';
        g.warnings.slice(0, 2).forEach(warn => {
          html += `<div style="color:#888;">‚Ä¢ ${warn}</div>`;
        });
        html += '</div>';
      }

      html += '</div>';
    });
  }

  el.innerHTML = html;

  // Update header badge
  const badge = document.getElementById('compliance-status');
  badge.className = `compliance-badge ${validation.overall}`;
  document.getElementById('compliance-text').textContent = `OAA v6.1.0 ${statusText}`;
  badge.style.display = 'inline-flex';

  // Show/hide upgrade button based on compliance
  const upgradeBtn = document.getElementById('btn-run-oaa');
  if (upgradeBtn) {
    upgradeBtn.style.display = validation.overall !== 'pass' ? 'inline-block' : 'none';
  }

  // Show/hide save to library button (visible when compliant)
  const saveBtn = document.getElementById('btn-save-library');
  if (saveBtn) {
    saveBtn.style.display = validation.overall === 'pass' ? 'inline-block' : 'none';
  }
}

function renderAuditPanel(audit) {
  lastAudit = audit;
  const el = document.getElementById('audit-content');
  let html = '';

  // Summary
  html += `<div class="audit-section"><h4>Summary</h4>`;
  html += `<div class="audit-item">Format: <strong>${audit.format}</strong></div>`;
  html += `<div class="audit-item">${audit.totalNodes} nodes, ${audit.totalEdges} edges</div>`;
  html += `<div class="audit-item">Connected components: ${audit.components.length} `;
  html += audit.disconnectedCount === 0
    ? `<span class="audit-badge ok">Fully connected</span>`
    : `<span class="audit-badge warn">${audit.disconnectedCount} disconnected</span>`;
  html += `</div>`;
  html += `<div class="audit-item">Main component: ${audit.mainComponentSize} nodes</div>`;
  html += `</div>`;

  // Stub nodes
  if (audit.stubNodes.length > 0) {
    html += `<div class="audit-section"><h4>Auto-created stubs <span class="audit-badge warn">${audit.stubNodes.length}</span></h4>`;
    audit.stubNodes.forEach(id => {
      html += `<div class="audit-item" onclick="focusNode('${id.replace(/'/g, "\\'")}')">${id}</div>`;
    });
    html += `</div>`;
  }

  // Isolated nodes
  if (audit.isolated.length > 0) {
    html += `<div class="audit-section"><h4>Isolated nodes (silos) <span class="audit-badge warn">${audit.isolated.length}</span></h4>`;
    audit.isolated.forEach(n => {
      html += `<div class="audit-item" onclick="focusNode('${n.id.replace(/'/g, "\\'")}')">${n.label} <span style="color:#666">(${n.entityType})</span></div>`;
    });
    html += `</div>`;
  }

  // Disconnected components (skip the main one)
  if (audit.components.length > 1) {
    html += `<div class="audit-section"><h4>Disconnected clusters</h4>`;
    audit.components.slice(1).forEach((comp, i) => {
      const preview = comp.slice(0, 3).join(', ') + (comp.length > 3 ? '...' : '');
      html += `<div class="audit-item" onclick="focusNodes(${JSON.stringify(comp)})">Cluster ${i + 1}: ${comp.length} nodes ‚Äî ${preview}</div>`;
    });
    html += `</div>`;
  }

  if (audit.stubNodes.length === 0 && audit.isolated.length === 0 && audit.disconnectedCount === 0) {
    html += `<div class="audit-section"><div class="audit-item" style="color:#86efac;">Graph is fully connected with no issues.</div></div>`;
  }

  el.innerHTML = html;
}

function focusNode(id) {
  if (network) { network.selectNodes([id]); network.focus(id, { scale: 1.5, animation: true }); }
}

function focusNodes(ids) {
  if (network) { network.selectNodes(ids); network.fit({ nodes: ids, animation: true }); }
}

// --- Rendering ---
function renderGraph(parsed) {
  lastParsed = parsed; // Store for connections/schema/data tabs

  // Fix 5: detect silos for visual highlighting
  const audit = auditGraph(parsed);
  renderAuditPanel(audit);

  // OAA v6.1.0 Validation
  const validation = validateOAAv5(currentData, parsed);
  renderOAACompliancePanel(validation);
  const siloNodeIds = new Set();
  audit.isolated.forEach(n => siloNodeIds.add(n.id));
  if (audit.components.length > 1) {
    audit.components.slice(1).forEach(comp => comp.forEach(id => siloNodeIds.add(id)));
  }

  const visNodes = parsed.nodes.map(n => {
    const isSilo = siloNodeIds.has(n.id);
    return {
      id: n.id,
      label: n.label,
      color: {
        background: TYPE_COLORS[n.entityType] || TYPE_COLORS.default,
        border: isSilo ? '#FF9800' : '#222',
        highlight: { background: '#9dfff5', border: '#017c75' }
      },
      borderWidth: isSilo ? 3 : 2,
      borderWidthSelected: 4,
      shapeProperties: { borderDashes: isSilo ? [6, 3] : false },
      font: { color: '#e0e0e0', size: 13 },
      shape: n.entityType === 'agent' ? 'star' : n.entityType === 'layer' ? 'box' : 'dot',
      size: n.entityType === 'agent' ? 25 : n.entityType === 'core' ? 30 : 20,
      title: n.description || n.label,
      _data: n
    };
  });

  // Fix 3: improved edge rendering
  const visEdges = parsed.edges.map(e => ({
    from: e.from,
    to: e.to,
    label: e.label,
    color: { color: EDGE_COLORS[e.edgeType] || EDGE_COLORS.default, highlight: '#9dfff5' },
    font: { color: '#888', size: 10, strokeWidth: 2, strokeColor: '#0f1117' },
    arrows: 'to',
    dashes: e.edgeType === 'inheritance',
    width: e.edgeType === 'binding' ? 2.5 : 1.5,
    smooth: { type: 'continuous', roundness: 0.3 }
  }));

  const container = document.getElementById('network');
  const data = { nodes: new vis.DataSet(visNodes), edges: new vis.DataSet(visEdges) };

  const options = {
    physics: {
      enabled: physicsEnabled,
      stabilization: { iterations: 200 },
      barnesHut: { gravitationalConstant: -3000, springLength: 150 }
    },
    interaction: { hover: true, tooltipDelay: 200 },
    nodes: { borderWidth: 2 },
    edges: { smooth: { type: 'continuous', roundness: 0.3 } },
    layout: {}
  };

  network = new vis.Network(container, data, options);

  network.once('stabilizationIterationsDone', function() {
    network.fit({ animation: true });
  });

  network.on('click', function(params) {
    if (params.nodes.length > 0) {
      const nodeId = params.nodes[0];
      const node = visNodes.find(n => n.id === nodeId);
      if (node) showNodeDetails(node._data);
    }
  });

  // Double-click to focus and drill into connections
  network.on('doubleClick', function(params) {
    if (params.nodes.length > 0) {
      const nodeId = params.nodes[0];
      const node = visNodes.find(n => n.id === nodeId);
      if (node) {
        showNodeDetails(node._data);
        switchTab('connections');
      }
    }
  });

  document.getElementById('stats').textContent =
    `${parsed.nodes.length} nodes | ${parsed.edges.length} edges | ${parsed.name} [${parsed.diagnostics.format}]`;

  buildLegend(parsed.nodes);
}

function showNodeDetails(node) {
  const sidebar = document.getElementById('sidebar');
  sidebar.classList.add('open');
  currentNodeId = node.id;

  document.getElementById('sidebar-title').textContent = node.label || node.id;

  // Details tab
  let detailsHtml = '';
  detailsHtml += field('ID', node.id);
  detailsHtml += field('Label', node.label);
  detailsHtml += field('Type', node.entityType);
  if (node.description) detailsHtml += field('Description', node.description);

  if (node.properties && typeof node.properties === 'object') {
    for (const [k, v] of Object.entries(node.properties)) {
      if (['id', 'name', 'label', 'description', 'entityType', 'type', '@id', '@type', 'properties'].includes(k)) continue;
      const val = typeof v === 'object' ? JSON.stringify(v, null, 2) : v;
      detailsHtml += field(k, val);
    }
  }
  document.getElementById('tab-details').innerHTML = detailsHtml;

  // Connections tab
  renderConnectionsTab(node.id);

  // Schema tab
  renderSchemaTab(node);

  // Data tab
  renderDataTab(node.id);

  // Reset to details tab
  switchTab('details');
}

function renderConnectionsTab(nodeId) {
  if (!lastParsed) return;

  const incoming = lastParsed.edges.filter(e => e.to === nodeId);
  const outgoing = lastParsed.edges.filter(e => e.from === nodeId);

  let html = '';

  // Outgoing connections
  html += `<div class="conn-section"><h4>Outgoing (${outgoing.length})</h4>`;
  if (outgoing.length === 0) {
    html += '<p class="no-data">No outgoing connections</p>';
  } else {
    outgoing.forEach(e => {
      const targetNode = lastParsed.nodes.find(n => n.id === e.to);
      const targetLabel = targetNode ? targetNode.label : e.to;
      html += `<div class="connection-item" onclick="navigateToNode('${e.to.replace(/'/g, "\\'")}')">
        <span class="connection-arrow">‚Üí</span>
        <span class="connection-label">${e.label || 'relates to'}</span>
        <span class="connection-node">${targetLabel}</span>
      </div>`;
    });
  }
  html += '</div>';

  // Incoming connections
  html += `<div class="conn-section"><h4>Incoming (${incoming.length})</h4>`;
  if (incoming.length === 0) {
    html += '<p class="no-data">No incoming connections</p>';
  } else {
    incoming.forEach(e => {
      const sourceNode = lastParsed.nodes.find(n => n.id === e.from);
      const sourceLabel = sourceNode ? sourceNode.label : e.from;
      html += `<div class="connection-item" onclick="navigateToNode('${e.from.replace(/'/g, "\\'")}')">
        <span class="connection-arrow">‚Üê</span>
        <span class="connection-label">${e.label || 'relates to'}</span>
        <span class="connection-node">${sourceLabel}</span>
      </div>`;
    });
  }
  html += '</div>';

  // Summary
  const total = incoming.length + outgoing.length;
  html += `<div class="conn-section"><h4>Summary</h4>`;
  html += `<div style="font-size:12px; color:#ccc;">Total connections: ${total}</div>`;
  if (total === 0) {
    html += `<div style="font-size:12px; color:#FF9800; margin-top:4px;">This node is isolated (no edges)</div>`;
  }
  html += '</div>';

  document.getElementById('tab-connections').innerHTML = html;
}

function renderSchemaTab(node) {
  let html = '';
  const props = node.properties || {};

  // Inheritance hierarchy (rdfs:subClassOf)
  const subClassOf = props['rdfs:subClassOf'] || props.subClassOf;
  if (subClassOf) {
    const parentId = typeof subClassOf === 'object' ? (subClassOf['@id'] || subClassOf.id) : subClassOf;
    if (parentId) {
      html += '<div class="conn-section"><h4>Inherits From</h4>';
      html += `<div class="connection-item" onclick="navigateToNode('${parentId.replace(/'/g, "\\'")}')">
        <span class="connection-arrow">‚Üë</span>
        <span class="connection-node">${parentId.replace(/.*[:#]/, '')}</span>
      </div>`;
      html += '</div>';
    }
  }

  // Schema.org mapping
  if (props.schemaOrgBase) {
    html += '<div class="conn-section"><h4>Schema.org Base</h4>';
    html += `<div style="font-size:12px; color:#9dfff5;">${props.schemaOrgBase}</div>`;
    html += '</div>';
  }

  // Extract schema properties - support oaa:properties, properties, attributes
  const schemaProps = props['oaa:properties'] || props.properties || props.attributes || [];

  if (Array.isArray(schemaProps) && schemaProps.length > 0) {
    html += '<div class="conn-section"><h4>Data Properties</h4>';
    schemaProps.forEach(p => {
      const name = p.name || p['@id'] || p.id || 'unknown';
      const type = p.type || p.dataType || p['@type'] || p.range || 'any';
      const required = p.required || p.minCount > 0;
      const desc = p.description || '';
      const schemaOrg = p.schemaOrgMapping || '';
      html += `<div class="prop-row" title="${desc}${schemaOrg ? ' (' + schemaOrg + ')' : ''}">
        <span class="prop-name">${name}${required ? '<span class="prop-required">*</span>' : ''}</span>
        <span class="prop-type">${type}${p.enumValues ? ' [' + p.enumValues.slice(0,3).join('|') + (p.enumValues.length > 3 ? '...' : '') + ']' : ''}</span>
      </div>`;
    });
    html += '</div>';
  }

  // Relationship participation (what relationships use this entity)
  if (lastParsed) {
    const nodeId = node.id;
    const asSource = lastParsed.edges.filter(e => e.from === nodeId);
    const asTarget = lastParsed.edges.filter(e => e.to === nodeId);

    if (asSource.length > 0 || asTarget.length > 0) {
      html += '<div class="conn-section"><h4>Relationship Participation</h4>';

      // Group by relationship type
      const relTypes = new Map();
      asSource.forEach(e => {
        const key = `‚Üí ${e.label || 'relates to'}`;
        if (!relTypes.has(key)) relTypes.set(key, []);
        relTypes.get(key).push(e.to);
      });
      asTarget.forEach(e => {
        const key = `‚Üê ${e.label || 'relates to'}`;
        if (!relTypes.has(key)) relTypes.set(key, []);
        relTypes.get(key).push(e.from);
      });

      relTypes.forEach((targets, rel) => {
        const targetLabels = targets.map(t => {
          const n = lastParsed.nodes.find(x => x.id === t);
          return n ? n.label : t.replace(/.*[:#]/, '');
        }).slice(0, 3);
        html += `<div style="font-size:11px; color:#888; margin:4px 0;">
          <span style="color:#9dfff5;">${rel}</span> ${targetLabels.join(', ')}${targets.length > 3 ? '...' : ''}
        </div>`;
      });
      html += '</div>';
    }
  }

  // Check for inline property definitions in the entity itself
  const inlineProps = [];
  const skipKeys = ['id', 'name', 'label', 'description', 'entityType', 'type', '@id', '@type',
                    'properties', 'attributes', 'schemaOrgBase', 'oaa:properties', 'oaa:description',
                    'rdfs:label', 'rdfs:comment', 'rdfs:subClassOf', 'subClassOf'];
  for (const [k, v] of Object.entries(props)) {
    if (skipKeys.includes(k)) continue;
    if (typeof v === 'string' || typeof v === 'number' || typeof v === 'boolean') {
      inlineProps.push({ name: k, type: typeof v, value: v });
    }
  }

  if (inlineProps.length > 0) {
    html += '<div class="conn-section"><h4>Metadata</h4>';
    inlineProps.forEach(p => {
      html += `<div class="prop-row">
        <span class="prop-name">${p.name}</span>
        <span class="prop-type">${p.type}</span>
      </div>`;
    });
    html += '</div>';
  }

  if (!html) {
    html = '<p class="no-data">No schema information available for this entity</p>';
  }

  document.getElementById('tab-schema').innerHTML = html;
}

function renderDataTab(nodeId) {
  let html = '';

  // Look for test data in currentData
  const testData = findTestData(nodeId);

  if (testData.length === 0) {
    html = '<p class="no-data">No data instances found for this entity.<br><br>Load an ontology with testData or instances to see sample values.</p>';
  } else {
    html += `<div style="font-size:11px; color:#888; margin-bottom:12px;">${testData.length} instance(s) found</div>`;
    testData.forEach((instance, idx) => {
      const instanceType = instance._dataType || 'typical';
      html += `<div class="data-instance">
        <div class="data-instance-header">
          <span class="data-instance-id">${instance.id || instance['@id'] || instance.name || 'Instance ' + (idx + 1)}</span>
          <span class="data-instance-type ${instanceType}">${instanceType}</span>
        </div>`;

      for (const [k, v] of Object.entries(instance)) {
        if (k === '_dataType' || k === '_entityType') continue;
        const displayVal = typeof v === 'object' ? JSON.stringify(v) : v;
        html += `<div class="data-row">
          <span class="data-key">${k}</span>
          <span class="data-value">${displayVal}</span>
        </div>`;
      }
      html += '</div>';
    });
  }

  document.getElementById('tab-data').innerHTML = html;
}

function findTestData(entityId) {
  if (!currentData) return [];

  const results = [];

  // Check various test data locations
  const testDataSources = [
    currentData.testData,
    currentData.testInstances,
    currentData.instances,
    currentData.sampleData,
    currentData.data,
    currentData.ontologyDefinition?.testData,
    currentData.registryEntry?.testData
  ];

  for (const source of testDataSources) {
    if (!source) continue;

    // If source is an object with entity keys
    if (typeof source === 'object' && !Array.isArray(source)) {
      // Check for exact match or partial match
      for (const [key, instances] of Object.entries(source)) {
        if (key === entityId || key.toLowerCase() === entityId.toLowerCase() ||
            entityId.includes(key) || key.includes(entityId)) {
          if (Array.isArray(instances)) {
            instances.forEach(inst => {
              results.push({ ...inst, _entityType: key, _dataType: inst.testCategory || inst.dataType || 'typical' });
            });
          } else if (typeof instances === 'object') {
            results.push({ ...instances, _entityType: key, _dataType: instances.testCategory || 'typical' });
          }
        }
      }
    }

    // If source is an array, filter by entityType
    if (Array.isArray(source)) {
      source.forEach(inst => {
        const instType = inst.entityType || inst['@type'] || inst.type || '';
        if (instType === entityId || instType.includes(entityId) || entityId.includes(instType)) {
          results.push({ ...inst, _dataType: inst.testCategory || inst.dataType || 'typical' });
        }
      });
    }
  }

  // Also check 60-20-10-10 distribution structure
  const distributions = ['typical', 'edge', 'boundary', 'invalid'];
  for (const dist of distributions) {
    const distData = currentData[dist] || currentData.testData?.[dist];
    if (distData && typeof distData === 'object') {
      for (const [key, instances] of Object.entries(distData)) {
        if (key === entityId || key.toLowerCase() === entityId.toLowerCase()) {
          if (Array.isArray(instances)) {
            instances.forEach(inst => results.push({ ...inst, _entityType: key, _dataType: dist }));
          }
        }
      }
    }
  }

  return results.slice(0, 10); // Limit to 10 instances for display
}

function navigateToNode(nodeId) {
  if (!network || !lastParsed) return;

  // Find the node
  const node = lastParsed.nodes.find(n => n.id === nodeId);
  if (!node) return;

  // Focus on the node in the graph
  network.selectNodes([nodeId]);
  network.focus(nodeId, { scale: 1.5, animation: true });

  // Update sidebar
  showNodeDetails(node);
}

function switchTab(tabName) {
  // Update tab buttons
  document.querySelectorAll('.sidebar-tab').forEach(btn => {
    btn.classList.toggle('active', btn.textContent.toLowerCase() === tabName);
  });

  // Update tab content
  ['details', 'connections', 'schema', 'data'].forEach(name => {
    const el = document.getElementById('tab-' + name);
    if (el) el.style.display = name === tabName ? 'block' : 'none';
  });
}

function field(label, value) {
  return `<div class="field"><div class="field-label">${label}</div><div class="field-value">${value}</div></div>`;
}

function buildLegend(nodes) {
  const types = [...new Set(nodes.map(n => n.entityType))];
  const legend = document.getElementById('legend');
  legend.style.display = 'block';
  legend.innerHTML = types.map(t =>
    `<div class="legend-item"><div class="legend-dot" style="background:${TYPE_COLORS[t] || TYPE_COLORS.default}"></div>${t}</div>`
  ).join('');
}

function togglePhysics() {
  physicsEnabled = !physicsEnabled;
  document.getElementById('btn-physics').classList.toggle('active');
  if (network) network.setOptions({ physics: { enabled: physicsEnabled } });
}

function changeLayout() {
  const layout = document.getElementById('layout-select').value;
  if (!network) return;
  const opts = { layout: {} };
  if (layout === 'hierarchical') {
    opts.layout = { hierarchical: { direction: 'UD', sortMethod: 'hubsize', levelSeparation: 120 } };
    opts.physics = { enabled: false };
  } else if (layout === 'circular') {
    opts.physics = { enabled: true, barnesHut: { gravitationalConstant: -1000, centralGravity: 0.8, springLength: 100 } };
    setTimeout(() => { if (network) network.setOptions({ physics: { enabled: false } }); }, 2000);
  } else {
    opts.physics = { enabled: physicsEnabled };
  }
  network.setOptions(opts);
}

function fitGraph() {
  if (network) network.fit({ animation: true });
}

function resetGraph() {
  if (!currentData) {
    // No data loaded - hide compliance badge
    document.getElementById('compliance-status').style.display = 'none';
    return;
  }

  // Re-parse from original data
  const fileName = document.getElementById('file-name').textContent || 'reset';
  const parsed = parseOntology(currentData, fileName);

  // Re-render (triggers stabilization back to equilibrium)
  renderGraph(parsed);

  // Close panels
  document.getElementById('sidebar').classList.remove('open');
  document.getElementById('audit-panel').classList.remove('open');

  // Reset physics toggle state
  physicsEnabled = true;
  document.getElementById('btn-physics').classList.add('active');

  // Reset layout dropdown
  document.getElementById('layout-select').value = 'physics';
}

function exportPNG() {
  if (!network) return;
  const canvas = document.querySelector('#network canvas');
  if (canvas) {
    const link = document.createElement('a');
    link.download = 'ontology-graph.png';
    link.href = canvas.toDataURL('image/png');
    link.click();
  }
}

function toggleSidebar() {
  document.getElementById('sidebar').classList.toggle('open');
}

// Load supplementary test data file to merge with current ontology
function loadTestDataFile() {
  if (!currentData) {
    alert('Load an ontology first, then add test data.');
    return;
  }

  const input = document.createElement('input');
  input.type = 'file';
  input.accept = '.json';
  input.onchange = function(e) {
    const file = e.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = function(ev) {
      try {
        const testData = JSON.parse(ev.target.result);

        // Merge test data into currentData
        if (testData.testData) {
          currentData.testData = { ...currentData.testData, ...testData.testData };
        } else if (testData.instances || testData.sampleData) {
          currentData.testData = testData.instances || testData.sampleData;
        } else if (Array.isArray(testData)) {
          currentData.testData = currentData.testData || {};
          testData.forEach(inst => {
            const entityType = inst.entityType || inst['@type'] || 'unknown';
            if (!currentData.testData[entityType]) currentData.testData[entityType] = [];
            currentData.testData[entityType].push(inst);
          });
        } else {
          // Assume the entire object is test data organized by entity
          currentData.testData = { ...currentData.testData, ...testData };
        }

        // If a node is selected, refresh the data tab
        if (currentNodeId) {
          renderDataTab(currentNodeId);
        }

        alert('Test data loaded successfully! Click on entities to see their data in the Data tab.');
      } catch (err) {
        alert('Failed to parse test data: ' + err.message);
      }
    };
    reader.readAsText(file);
  };
  input.click();
}

function toggleAudit() {
  document.getElementById('audit-panel').classList.toggle('open');
}

// --- GitHub API integration ---
function loadFromGitHub() {
  let pat = sessionStorage.getItem('gh_pat');
  if (!pat) {
    pat = prompt('Enter GitHub Personal Access Token (stored in session only):');
    if (!pat) return;
    sessionStorage.setItem('gh_pat', pat);
  }
  const path = prompt('Enter repo path: owner/repo/path/to/file.json\nExample: ajrmooreuk/PF-Core-BAIV/PBS/ONTOLOGIES/my-ontology.json');
  if (!path) return;

  const parts = path.split('/');
  if (parts.length < 3) { alert('Format: owner/repo/path/to/file.json'); return; }
  const owner = parts[0];
  const repo = parts[1];
  const filePath = parts.slice(2).join('/');
  const url = `https://api.github.com/repos/${owner}/${repo}/contents/${filePath}`;

  document.getElementById('file-name').textContent = `Loading ${filePath}...`;
  fetch(url, { headers: { 'Authorization': `token ${pat}`, 'Accept': 'application/vnd.github.v3.raw' } })
    .then(res => {
      if (!res.ok) throw new Error(`GitHub API ${res.status}: ${res.statusText}`);
      return res.json();
    })
    .then(data => {
      currentData = data;
      document.getElementById('file-name').textContent = filePath;
      const parsed = parseOntology(data, filePath.split('/').pop());
      if (parsed.nodes.length === 0) {
        alert('No nodes parsed. Keys: ' + Object.keys(data).join(', '));
        return;
      }
      renderGraph(parsed);
      dropZone.classList.add('hidden');
    })
    .catch(err => {
      if (err.message.includes('401')) { sessionStorage.removeItem('gh_pat'); }
      alert('GitHub load failed: ' + err.message);
      document.getElementById('file-name').textContent = '';
    });
}

// ========================================
// OAA v6.1.0 UPGRADE VIA CLAUDE CODE CLI
// ========================================

function runOAAUpgrade() {
  if (!currentData) {
    alert('Load an ontology first');
    return;
  }

  // Get current compliance status
  const validation = validateOAAv5(currentData, lastParsed);
  const fileName = document.getElementById('file-name').textContent || 'ontology';
  const baseName = fileName.replace(/\.json$/i, '');

  // Generate output filename
  const outputName = `${baseName}-oaa-v6-upgraded.json`;

  // Build the prompt for Claude Code
  const prompt = buildOAAPrompt(currentData, validation);

  // Show modal with options
  showOAAModal(prompt, outputName);
}

function buildOAAPrompt(ontology, validation) {
  const issues = [];
  const orphanedEntities = [];
  const missingDescriptions = [];

  validation.gates.forEach(g => {
    if (g.status === 'fail') {
      issues.push(`FAIL: ${g.gate} - ${g.detail}`);
      // Collect orphaned entities from G2B
      if (g.gate.includes('2B') && g.orphaned) {
        orphanedEntities.push(...g.orphaned);
      }
    }
    if (g.status === 'warn') {
      issues.push(`WARN: ${g.gate} - ${g.detail}`);
      // Collect missing descriptions from G4
      if (g.gate.includes('G4') && g.warnings) {
        g.warnings.forEach(w => {
          if (w.includes('missing description')) {
            const match = w.match(/^([^:]+):/);
            if (match) missingDescriptions.push(match[1]);
          }
        });
      }
    }
  });

  // Build detailed prompt with OAA v6.1.0 requirements
  let prompt = `You are the OAA (Ontology Architect Agent) v6.1.0.

Upgrade this ontology to pass ALL OAA v6.1.0 core compliance gates (G1-G4).

## OAA v6.1.0 Core Gates (REQUIRED - must pass at 100%)

| Gate | Requirement |
|------|-------------|
| G1 | Schema Structure: Valid JSON-LD with @context, @id, entities |
| G2 | Relationship Cardinality: All relationships have domainIncludes/rangeIncludes with cardinality |
| G2B | Entity Connectivity: EVERY entity must participate in ‚â•1 relationship |
| G2C | Graph Connectivity: All entities form a SINGLE connected component |
| G3 | Business Rules: IF-THEN format with severity levels |
| G4 | Semantic Consistency: All entities have descriptions (‚â•20 chars) |

## Advisory Gates (Recommended but not required for compliance)

| Gate | Requirement |
|------|-------------|
| G5 | Completeness: Version, metadata, edge-to-node ratio ‚â•0.8 |
| G6 | UniRegistry Format: If applicable, valid registry structure |

## Current Compliance Status
${issues.length > 0 ? issues.filter(i => !i.includes('G5:') && !i.includes('G6:')).join('\n') : 'No critical issues, but validate and enhance.'}`;

  // Add specific orphaned entities if any
  if (orphanedEntities.length > 0) {
    prompt += `

## CRITICAL: Orphaned Entities (G2B FAIL)
These entities have ZERO relationships and MUST be connected:
${orphanedEntities.map(e => `- ${e}`).join('\n')}

For EACH orphaned entity, add at least one relationship where it appears as:
- domainIncludes (source) OR
- rangeIncludes (target)`;
  }

  // Add missing descriptions if any
  if (missingDescriptions.length > 0) {
    prompt += `

## Missing Descriptions (G4)
Add descriptions (‚â•20 characters) for:
${missingDescriptions.slice(0, 10).map(e => `- ${e}`).join('\n')}${missingDescriptions.length > 10 ? `\n... and ${missingDescriptions.length - 10} more` : ''}`;
  }

  prompt += `

## Current Ontology
\`\`\`json
${JSON.stringify(ontology, null, 2)}
\`\`\`

## Required Output Format
Produce a compliant ontology with:
1. All entities connected via relationships (no orphans)
2. Relationships with proper domainIncludes/rangeIncludes arrays
3. Descriptions for all entities (‚â•20 characters each)
4. Cardinality notation on relationships (e.g., "1..*", "0..1")
5. Single connected graph (all entities reachable from any other)

Output ONLY valid JSON. No explanations, no markdown, no code blocks.`;

  return prompt;
}

function showOAAModal(prompt, outputName) {
  const modal = document.getElementById('oaa-modal');
  const body = document.getElementById('oaa-modal-body');

  // Escape for shell (handle single quotes)
  const escapedPrompt = prompt.replace(/'/g, "'\\''");

  // Extract domain from ontology for path suggestion
  const domain = extractOntologyDomain(currentData);
  const domainFolder = domain ? domain.toUpperCase().replace(/\s+/g, '-') + '-ONT' : 'DOMAIN-ONT';
  const suggestedPath = `PBS/ONTOLOGIES/pfc-ontologies/${domainFolder}/${outputName}`;

  // Claude Code command - use -p flag for prompt
  const command = `claude -p '${escapedPrompt}' > ${outputName}`;

  body.innerHTML = `
    <p style="color:#888; margin-bottom:16px;">Copy this command and run it in your terminal with Claude Code:</p>

    <div class="oaa-command" id="oaa-command">${escapeHtml(command)}</div>

    <div style="margin-bottom:16px;">
      <button class="oaa-btn" onclick="copyOAACommand()">Copy Command</button>
      <button class="oaa-btn oaa-btn-secondary" onclick="downloadOntologyForOAA()">Download Ontology JSON</button>
    </div>

    <details style="margin-top:16px;" open>
      <summary style="color:#9dfff5; cursor:pointer; font-weight:500;">Recommended file path</summary>
      <div style="background:#0d0f12; border:1px solid #3a3d47; border-radius:6px; padding:12px; margin-top:8px;">
        <code style="color:#9dfff5; font-size:12px; word-break:break-all;">${escapeHtml(suggestedPath)}</code>
        <button class="oaa-btn" style="margin-left:12px; padding:4px 8px; font-size:11px;" onclick="copyPath('${escapeHtml(suggestedPath)}', this)">Copy Path</button>
      </div>
      <p style="color:#666; margin-top:8px; font-size:11px;">
        Standard pattern: <code style="background:#0d0f12; padding:2px 6px; border-radius:3px;">PBS/ONTOLOGIES/pfc-ontologies/{DOMAIN}-ONT/{filename}</code>
      </p>
    </details>

    <details style="margin-top:12px;">
      <summary style="color:#888; cursor:pointer;">Alternative: Use file input</summary>
      <p style="color:#666; margin-top:8px; font-size:12px;">
        1. Download the ontology JSON using the button above<br>
        2. Run: <code style="background:#0d0f12; padding:2px 6px; border-radius:3px;">claude -p "Upgrade this ontology to OAA v6.1.0 compliance" &lt; ${outputName.replace('-upgraded', '-for-oaa')}</code>
      </p>
    </details>

    <div style="margin-top:20px; padding-top:16px; border-top:1px solid #3a3d47;">
      <p style="color:#888; font-size:12px;">After running, load the output file back into the Visualiser to verify compliance.</p>
    </div>
  `;

  modal.style.display = 'flex';
}

// Extract domain from ontology data
function extractOntologyDomain(data) {
  if (!data) return null;
  // Try various domain field locations
  return data['oaa:domain'] ||
         data.domain ||
         (data['rdfs:label'] && data['rdfs:label'].split(' ')[0]) ||
         (data.name && data.name.split(' ')[0]) ||
         null;
}

// Copy path to clipboard
function copyPath(path, btn) {
  navigator.clipboard.writeText(path).then(() => {
    const original = btn.textContent;
    btn.textContent = 'Copied!';
    setTimeout(() => btn.textContent = original, 2000);
  });
}

function closeOAAModal() {
  document.getElementById('oaa-modal').style.display = 'none';
}

function copyOAACommand() {
  const command = document.getElementById('oaa-command').textContent;
  navigator.clipboard.writeText(command).then(() => {
    const btn = event.target;
    const original = btn.textContent;
    btn.textContent = 'Copied!';
    setTimeout(() => btn.textContent = original, 2000);
  });
}

function downloadOntologyForOAA() {
  const blob = new Blob([JSON.stringify(currentData, null, 2)], {type: 'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  const fileName = document.getElementById('file-name').textContent || 'ontology';
  a.download = fileName.replace(/\.json$/i, '') + '-for-oaa.json';
  a.click();
  URL.revokeObjectURL(url);
}

function escapeHtml(text) {
  const div = document.createElement('div');
  div.textContent = text;
  return div.innerHTML;
}

// Close modal on background click
document.addEventListener('click', (e) => {
  const modal = document.getElementById('oaa-modal');
  if (e.target === modal) closeOAAModal();
});

// Close modal on Escape key
document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape') {
    closeOAAModal();
    closeSaveLibraryModal();
  }
});

// ========================================
// ONTOLOGY LIBRARY (IndexedDB)
// ========================================

let libraryDB = null;
const DB_NAME = 'OntologyLibrary';
const DB_VERSION = 1;

// Default categories for organizing ontologies
const DEFAULT_CATEGORIES = [
  'pfc-ontologies',
  'pfi-ontologies',
  'domain-ontologies',
  'custom'
];

// Initialize IndexedDB
function initLibraryDB() {
  return new Promise((resolve, reject) => {
    if (libraryDB) { resolve(libraryDB); return; }

    const request = indexedDB.open(DB_NAME, DB_VERSION);

    request.onerror = () => reject(request.error);

    request.onsuccess = () => {
      libraryDB = request.result;
      resolve(libraryDB);
    };

    request.onupgradeneeded = (event) => {
      const db = event.target.result;

      // Ontologies store - main storage
      if (!db.objectStoreNames.contains('ontologies')) {
        const ontologyStore = db.createObjectStore('ontologies', { keyPath: 'id', autoIncrement: true });
        ontologyStore.createIndex('name', 'name', { unique: false });
        ontologyStore.createIndex('category', 'category', { unique: false });
        ontologyStore.createIndex('updated', 'updated', { unique: false });
      }

      // Version history store - audit trail
      if (!db.objectStoreNames.contains('versions')) {
        const versionStore = db.createObjectStore('versions', { keyPath: 'id', autoIncrement: true });
        versionStore.createIndex('ontologyId', 'ontologyId', { unique: false });
        versionStore.createIndex('timestamp', 'timestamp', { unique: false });
      }
    };
  });
}

// Save ontology to library
async function saveOntologyToLibrary(ontologyData, name, category, version, notes = '') {
  const db = await initLibraryDB();

  return new Promise((resolve, reject) => {
    const transaction = db.transaction(['ontologies', 'versions'], 'readwrite');
    const ontologyStore = transaction.objectStore('ontologies');
    const versionStore = transaction.objectStore('versions');

    const now = new Date().toISOString();

    // Check if ontology with same name exists in category
    const index = ontologyStore.index('name');
    const getRequest = index.getAll(name);

    getRequest.onsuccess = () => {
      const existing = getRequest.result.find(o => o.category === category);

      if (existing) {
        // Update existing - increment version
        const oldVersion = existing.version;
        const newVersion = incrementVersion(oldVersion);

        // Save old version to history
        versionStore.add({
          ontologyId: existing.id,
          version: oldVersion,
          data: existing.data,
          timestamp: existing.updated,
          notes: `Auto-saved before upgrade to ${newVersion}`
        });

        // Update ontology
        existing.data = ontologyData;
        existing.version = version || newVersion;
        existing.updated = now;
        existing.compliance = validateOAAv5(ontologyData, parseOntology(ontologyData, name)).overall;

        ontologyStore.put(existing);

        transaction.oncomplete = () => resolve({
          id: existing.id,
          version: existing.version,
          isUpdate: true,
          previousVersion: oldVersion
        });
      } else {
        // Create new
        const newOntology = {
          name: name,
          category: category,
          version: version || '1.0.0',
          data: ontologyData,
          created: now,
          updated: now,
          compliance: validateOAAv5(ontologyData, parseOntology(ontologyData, name)).overall
        };

        const addRequest = ontologyStore.add(newOntology);
        addRequest.onsuccess = () => {
          resolve({
            id: addRequest.result,
            version: newOntology.version,
            isUpdate: false
          });
        };
      }
    };

    transaction.onerror = () => reject(transaction.error);
  });
}

// Increment semantic version
function incrementVersion(version) {
  const parts = version.split('.').map(Number);
  if (parts.length === 3) {
    parts[2]++; // Increment patch
    return parts.join('.');
  }
  return version + '.1';
}

// Load ontology from library
async function loadOntologyFromLibrary(id) {
  const db = await initLibraryDB();

  return new Promise((resolve, reject) => {
    const transaction = db.transaction(['ontologies'], 'readonly');
    const store = transaction.objectStore('ontologies');
    const request = store.get(id);

    request.onsuccess = () => resolve(request.result);
    request.onerror = () => reject(request.error);
  });
}

// Get all ontologies grouped by category
async function getAllOntologies() {
  const db = await initLibraryDB();

  return new Promise((resolve, reject) => {
    const transaction = db.transaction(['ontologies'], 'readonly');
    const store = transaction.objectStore('ontologies');
    const request = store.getAll();

    request.onsuccess = () => {
      const ontologies = request.result;
      // Group by category
      const grouped = {};
      DEFAULT_CATEGORIES.forEach(cat => grouped[cat] = []);

      ontologies.forEach(ont => {
        const cat = ont.category || 'custom';
        if (!grouped[cat]) grouped[cat] = [];
        grouped[cat].push(ont);
      });

      // Sort each category by updated date (newest first)
      Object.keys(grouped).forEach(cat => {
        grouped[cat].sort((a, b) => new Date(b.updated) - new Date(a.updated));
      });

      resolve(grouped);
    };
    request.onerror = () => reject(request.error);
  });
}

// Get version history for an ontology
async function getVersionHistory(ontologyId) {
  const db = await initLibraryDB();

  return new Promise((resolve, reject) => {
    const transaction = db.transaction(['versions'], 'readonly');
    const store = transaction.objectStore('versions');
    const index = store.index('ontologyId');
    const request = index.getAll(ontologyId);

    request.onsuccess = () => {
      const versions = request.result;
      versions.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
      resolve(versions);
    };
    request.onerror = () => reject(request.error);
  });
}

// Delete ontology from library
async function deleteFromLibrary(id) {
  const db = await initLibraryDB();

  return new Promise((resolve, reject) => {
    const transaction = db.transaction(['ontologies', 'versions'], 'readwrite');
    const ontologyStore = transaction.objectStore('ontologies');
    const versionStore = transaction.objectStore('versions');

    // Delete versions first
    const versionIndex = versionStore.index('ontologyId');
    const getVersions = versionIndex.getAll(id);

    getVersions.onsuccess = () => {
      getVersions.result.forEach(v => versionStore.delete(v.id));
      ontologyStore.delete(id);
    };

    transaction.oncomplete = () => resolve();
    transaction.onerror = () => reject(transaction.error);
  });
}

// Toggle library panel
function toggleLibrary() {
  const panel = document.getElementById('library-panel');
  const isOpen = panel.classList.toggle('open');
  if (isOpen) {
    refreshLibraryPanel();
  }
}

// Refresh library content
async function refreshLibraryPanel() {
  const content = document.getElementById('library-content');

  try {
    const grouped = await getAllOntologies();
    let html = '';
    let hasAny = false;

    for (const [category, ontologies] of Object.entries(grouped)) {
      if (ontologies.length === 0) continue;
      hasAny = true;

      const displayCategory = category.replace(/-/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
      html += `<div class="library-category">
        <h4>${displayCategory} (${ontologies.length})</h4>`;

      ontologies.forEach(ont => {
        const date = new Date(ont.updated).toLocaleDateString();
        const complianceClass = ont.compliance === 'pass' ? 'ok' : (ont.compliance === 'warn' ? 'warn' : 'fail');
        html += `
          <div class="library-item" onclick="loadFromLibrary(${ont.id})">
            <div class="library-item-header">
              <span class="library-item-name">${escapeHtml(ont.name)}</span>
              <span class="library-item-version">v${ont.version}</span>
            </div>
            <div class="library-item-meta">
              <span class="audit-badge ${complianceClass}">${ont.compliance}</span>
              <span>${date}</span>
            </div>
            <div class="library-item-actions" onclick="event.stopPropagation()">
              <button class="oaa-btn oaa-btn-secondary" onclick="showVersionHistory(${ont.id}, '${escapeHtml(ont.name)}')">History</button>
              <button class="oaa-btn oaa-btn-secondary" onclick="downloadOntology(${ont.id})">Download</button>
              <button class="oaa-btn oaa-btn-secondary" onclick="deleteOntology(${ont.id})" style="color:#fca5a5;">Delete</button>
            </div>
          </div>`;
      });

      html += '</div>';
    }

    if (!hasAny) {
      html = '<p class="library-empty">No ontologies saved yet.<br>Load an ontology and click "Save to Library" when it passes OAA v6.1.0 compliance.</p>';
    }

    content.innerHTML = html;
  } catch (err) {
    content.innerHTML = `<p class="library-empty" style="color:#fca5a5;">Error loading library: ${err.message}</p>`;
  }
}

// Load ontology from library
async function loadFromLibrary(id) {
  try {
    const ontology = await loadOntologyFromLibrary(id);
    if (!ontology) {
      alert('Ontology not found in library');
      return;
    }

    currentData = ontology.data;
    document.getElementById('file-name').textContent = `${ontology.name} (v${ontology.version})`;

    const parsed = parseOntology(ontology.data, ontology.name);
    if (parsed.nodes.length === 0) {
      alert('No nodes parsed from saved ontology');
      return;
    }

    renderGraph(parsed);
    document.getElementById('drop-zone').classList.add('hidden');
    toggleLibrary(); // Close library panel

  } catch (err) {
    alert('Error loading from library: ' + err.message);
  }
}

// Show save to library modal
function showSaveToLibrary() {
  if (!currentData) {
    alert('Load an ontology first');
    return;
  }

  const modal = document.getElementById('save-library-modal');
  const body = document.getElementById('save-library-body');

  // Get current name and suggested version
  const currentName = document.getElementById('file-name').textContent || 'Untitled Ontology';
  const baseName = currentName.replace(/\.json$/i, '').replace(/ \(v[\d.]+\)$/, '');
  const currentVersion = currentData['owl:versionInfo'] || currentData.version || '1.0.0';

  // Determine suggested category
  let suggestedCategory = 'custom';
  if (baseName.toLowerCase().includes('pfc') || baseName.toLowerCase().includes('platform-foundation')) {
    suggestedCategory = 'pfc-ontologies';
  } else if (baseName.toLowerCase().includes('pfi')) {
    suggestedCategory = 'pfi-ontologies';
  }

  body.innerHTML = `
    <div class="library-form-group">
      <label>Ontology Name</label>
      <input type="text" id="save-ont-name" class="library-input" value="${escapeHtml(baseName)}" placeholder="e.g., ppm-schema">
    </div>

    <div class="library-form-group">
      <label>Category / Folder</label>
      <select id="save-ont-category" class="library-select">
        ${DEFAULT_CATEGORIES.map(cat =>
          `<option value="${cat}" ${cat === suggestedCategory ? 'selected' : ''}>${cat.replace(/-/g, ' ')}</option>`
        ).join('')}
      </select>
    </div>

    <div class="library-form-group">
      <label>Version</label>
      <input type="text" id="save-ont-version" class="library-input" value="${escapeHtml(currentVersion)}" placeholder="e.g., 1.0.0">
    </div>

    <div class="library-form-group">
      <label>Notes (optional)</label>
      <input type="text" id="save-ont-notes" class="library-input" placeholder="e.g., Upgraded to OAA v6.1.0 compliance">
    </div>

    <div id="save-result"></div>

    <div style="margin-top:16px; display:flex; gap:8px;">
      <button class="oaa-btn" onclick="doSaveToLibrary()">Save to Library</button>
      <button class="oaa-btn oaa-btn-secondary" onclick="closeSaveLibraryModal()">Cancel</button>
    </div>

    <p style="color:#666; font-size:11px; margin-top:12px;">
      Saving creates a versioned entry in your local browser storage with full audit trail.
      Export the library for backup or sharing across devices.
    </p>
  `;

  modal.style.display = 'flex';
}

// Close save library modal
function closeSaveLibraryModal() {
  document.getElementById('save-library-modal').style.display = 'none';
}

// Perform save to library
async function doSaveToLibrary() {
  const name = document.getElementById('save-ont-name').value.trim();
  const category = document.getElementById('save-ont-category').value;
  const version = document.getElementById('save-ont-version').value.trim();
  const notes = document.getElementById('save-ont-notes').value.trim();
  const resultDiv = document.getElementById('save-result');

  if (!name) {
    resultDiv.innerHTML = '<p style="color:#fca5a5; font-size:12px;">Name is required</p>';
    return;
  }

  try {
    const result = await saveOntologyToLibrary(currentData, name, category, version, notes);

    resultDiv.innerHTML = `
      <div class="save-success">
        ‚úì Saved ${result.isUpdate ? 'updated' : 'new'} ontology: <strong>${name}</strong> v${result.version}
        ${result.isUpdate ? `<br><small>Previous version ${result.previousVersion} archived</small>` : ''}
      </div>
    `;

    // Update file name display
    document.getElementById('file-name').textContent = `${name} (v${result.version})`;

    // Refresh library panel if open
    if (document.getElementById('library-panel').classList.contains('open')) {
      refreshLibraryPanel();
    }

    // Close modal after short delay
    setTimeout(() => {
      closeSaveLibraryModal();
    }, 1500);

  } catch (err) {
    resultDiv.innerHTML = `<p style="color:#fca5a5; font-size:12px;">Error saving: ${err.message}</p>`;
  }
}

// Show version history
async function showVersionHistory(ontologyId, name) {
  try {
    const versions = await getVersionHistory(ontologyId);
    const ontology = await loadOntologyFromLibrary(ontologyId);

    const modal = document.getElementById('save-library-modal');
    const body = document.getElementById('save-library-body');

    let historyHtml = '';
    if (versions.length === 0) {
      historyHtml = '<p class="library-empty">No previous versions</p>';
    } else {
      historyHtml = '<div class="version-history">';
      versions.forEach(v => {
        const date = new Date(v.timestamp).toLocaleString();
        historyHtml += `
          <div class="version-item">
            <div class="version-item-info">
              <strong>v${v.version}</strong>
              <div class="version-item-date">${date}</div>
              ${v.notes ? `<div style="color:#888; font-size:10px;">${escapeHtml(v.notes)}</div>` : ''}
            </div>
            <button class="oaa-btn oaa-btn-secondary" onclick="restoreVersion(${v.id})" style="font-size:11px; padding:4px 8px;">Restore</button>
          </div>`;
      });
      historyHtml += '</div>';
    }

    body.innerHTML = `
      <h4 style="color:#e0e0e0; margin-bottom:12px;">${escapeHtml(name)}</h4>
      <p style="color:#888; font-size:12px; margin-bottom:12px;">Current version: v${ontology.version}</p>
      ${historyHtml}
      <div style="margin-top:16px;">
        <button class="oaa-btn oaa-btn-secondary" onclick="closeSaveLibraryModal()">Close</button>
      </div>
    `;

    modal.style.display = 'flex';

  } catch (err) {
    alert('Error loading version history: ' + err.message);
  }
}

// Restore a previous version
async function restoreVersion(versionId) {
  const db = await initLibraryDB();

  return new Promise((resolve, reject) => {
    const transaction = db.transaction(['versions'], 'readonly');
    const store = transaction.objectStore('versions');
    const request = store.get(versionId);

    request.onsuccess = async () => {
      const version = request.result;
      if (version) {
        // Load the old version data
        currentData = version.data;
        document.getElementById('file-name').textContent = `Restored v${version.version}`;

        const parsed = parseOntology(version.data, `Restored v${version.version}`);
        renderGraph(parsed);
        document.getElementById('drop-zone').classList.add('hidden');
        closeSaveLibraryModal();
        toggleLibrary();
      }
    };
  });
}

// Download ontology as JSON
async function downloadOntology(id) {
  try {
    const ontology = await loadOntologyFromLibrary(id);
    const blob = new Blob([JSON.stringify(ontology.data, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${ontology.name}-v${ontology.version}.json`;
    a.click();
    URL.revokeObjectURL(url);
  } catch (err) {
    alert('Error downloading: ' + err.message);
  }
}

// Delete ontology
async function deleteOntology(id) {
  if (!confirm('Delete this ontology and its version history?')) return;

  try {
    await deleteFromLibrary(id);
    refreshLibraryPanel();
  } catch (err) {
    alert('Error deleting: ' + err.message);
  }
}

// Export entire library as JSON
async function exportLibrary() {
  try {
    const db = await initLibraryDB();

    const ontologies = await new Promise((resolve, reject) => {
      const tx = db.transaction(['ontologies'], 'readonly');
      const req = tx.objectStore('ontologies').getAll();
      req.onsuccess = () => resolve(req.result);
      req.onerror = () => reject(req.error);
    });

    const versions = await new Promise((resolve, reject) => {
      const tx = db.transaction(['versions'], 'readonly');
      const req = tx.objectStore('versions').getAll();
      req.onsuccess = () => resolve(req.result);
      req.onerror = () => reject(req.error);
    });

    const exportData = {
      exportedAt: new Date().toISOString(),
      version: '1.0',
      ontologies,
      versions
    };

    const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `ontology-library-${new Date().toISOString().split('T')[0]}.json`;
    a.click();
    URL.revokeObjectURL(url);

  } catch (err) {
    alert('Error exporting library: ' + err.message);
  }
}

// Import library from JSON
function importLibrary() {
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = '.json';

  input.onchange = async (e) => {
    const file = e.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = async (evt) => {
      try {
        const importData = JSON.parse(evt.target.result);

        if (!importData.ontologies || !Array.isArray(importData.ontologies)) {
          throw new Error('Invalid library export format');
        }

        const db = await initLibraryDB();

        // Import ontologies
        const tx = db.transaction(['ontologies', 'versions'], 'readwrite');
        const ontStore = tx.objectStore('ontologies');
        const verStore = tx.objectStore('versions');

        let imported = 0;
        for (const ont of importData.ontologies) {
          // Remove id to let IndexedDB auto-generate
          const newOnt = { ...ont };
          delete newOnt.id;
          ontStore.add(newOnt);
          imported++;
        }

        if (importData.versions) {
          for (const ver of importData.versions) {
            const newVer = { ...ver };
            delete newVer.id;
            verStore.add(newVer);
          }
        }

        tx.oncomplete = () => {
          alert(`Imported ${imported} ontologies`);
          refreshLibraryPanel();
        };

      } catch (err) {
        alert('Error importing library: ' + err.message);
      }
    };
    reader.readAsText(file);
  };

  input.click();
}

// Update Save to Library button visibility based on compliance
function updateSaveLibraryButton(compliance) {
  const btn = document.getElementById('btn-save-library');
  if (btn) {
    // Show save button when ontology is compliant (pass or warn)
    btn.style.display = compliance === 'pass' ? 'inline-block' : 'none';
  }
}

// Initialize library on page load
initLibraryDB().catch(err => console.error('Failed to init library DB:', err));
</script>
</body>
</html>
