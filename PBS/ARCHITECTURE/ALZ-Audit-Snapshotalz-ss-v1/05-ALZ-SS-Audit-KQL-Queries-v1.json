{
  "metadata": {
    "name": "Pre-ALZ Audit KQL Queries",
    "version": "1.1.0",
    "description": "KQL queries for Azure Resource Graph snapshot audit - Insurance Advisory sector",
    "complianceFrameworks": ["MCSB v1", "MCSB v2", "NIST SP 800-53 Rev 5", "UK NCSC 14 Principles", "ISO 27001:2022"],
    "purpose": "Phase 1 Environment Audit - Baseline documentation for ALZ design",
    "usage": "Run via Azure Resource Graph Explorer, Azure CLI (az graph query), or Azure PowerShell (Search-AzGraph)"
  },
  "queries": {
    "summary": {
      "estateSummary": {
        "name": "Estate Summary Metrics",
        "description": "High-level counts for executive reporting",
        "outputFile": "summary-metrics.json",
        "query": "resources\n| summarize\n    TotalResources = count(),\n    ResourceTypes = dcount(type),\n    Subscriptions = dcount(subscriptionId),\n    ResourceGroups = dcount(resourceGroup),\n    Locations = dcount(location)"
      },
      "taggingCompliance": {
        "name": "Tagging Compliance Summary",
        "description": "Percentage of resources with tags",
        "outputFile": "tagging-compliance.json",
        "query": "resources\n| extend tagCount = array_length(bag_keys(tags))\n| summarize\n    Total = count(),\n    Tagged = countif(tagCount > 0),\n    Untagged = countif(tagCount == 0)\n| extend TaggingCompliance = round(100.0 * Tagged / Total, 1)"
      },
      "resourceTypeDistribution": {
        "name": "Resource Type Distribution",
        "description": "Count of resources by type",
        "outputFile": "resource-types.json",
        "query": "resources\n| summarize Count = count() by type\n| order by Count desc"
      },
      "regionDistribution": {
        "name": "Region Distribution",
        "description": "Count of resources by Azure region",
        "outputFile": "region-distribution.json",
        "query": "resources\n| summarize Count = count() by location\n| order by Count desc"
      }
    },
    "inventory": {
      "fullInventory": {
        "name": "Complete Resource Inventory",
        "description": "All resources with metadata",
        "outputFile": "inventory-full.json",
        "query": "resources\n| extend tagCount = array_length(bag_keys(tags))\n| project\n    Name = name,\n    Type = type,\n    Location = location,\n    ResourceGroup = resourceGroup,\n    SubscriptionId = subscriptionId,\n    SKU = tostring(sku.name),\n    Kind = kind,\n    TagCount = tagCount,\n    Tags = tostring(tags),\n    ResourceId = id\n| order by Type asc, Name asc"
      },
      "resourcesByType": {
        "name": "Resources by Type",
        "description": "Resource counts by type",
        "outputFile": "inventory-by-type.csv",
        "query": "resources\n| summarize Count = count() by type\n| order by Count desc\n| project ResourceType = type, Count"
      },
      "untaggedResources": {
        "name": "Untagged Resources",
        "description": "Governance gap - resources without tags",
        "outputFile": "untagged-resources.csv",
        "query": "resources\n| extend tagCount = array_length(bag_keys(tags))\n| where tagCount == 0\n| project Name = name, Type = type, ResourceGroup = resourceGroup, Location = location, SubscriptionId = subscriptionId\n| order by Type asc"
      },
      "tagKeyDistribution": {
        "name": "Tag Key Distribution",
        "description": "Most commonly used tag keys",
        "outputFile": "tag-keys.json",
        "query": "resources\n| mv-expand bagexpansion=array tags\n| extend tagKey = tostring(tags[0])\n| summarize Count = count() by tagKey\n| order by Count desc"
      }
    },
    "governance": {
      "managementGroups": {
        "name": "Management Group Hierarchy",
        "description": "Management groups for ALZ structure planning",
        "outputFile": "management-groups.json",
        "query": "resourcecontainers\n| where type == 'microsoft.management/managementgroups'\n| project\n    Name = name,\n    DisplayName = properties.displayName,\n    TenantId = properties.tenantId,\n    ParentId = tostring(properties.details.parent.id)\n| order by Name asc"
      },
      "subscriptions": {
        "name": "Subscription Inventory",
        "description": "All subscriptions with state",
        "outputFile": "subscriptions.json",
        "query": "resourcecontainers\n| where type == 'microsoft.resources/subscriptions'\n| project\n    SubscriptionName = name,\n    SubscriptionId = subscriptionId,\n    State = properties.state,\n    Tags = tostring(tags)\n| order by SubscriptionName asc"
      },
      "policyAssignments": {
        "name": "Policy Assignments",
        "description": "All policy assignments",
        "outputFile": "policy-assignments.json",
        "query": "policyresources\n| where type == 'microsoft.authorization/policyassignments'\n| project\n    AssignmentName = name,\n    DisplayName = properties.displayName,\n    Scope = properties.scope,\n    EnforcementMode = properties.enforcementMode,\n    PolicyDefinitionId = properties.policyDefinitionId\n| order by AssignmentName asc"
      },
      "policyComplianceByAssignment": {
        "name": "Policy Compliance by Assignment",
        "description": "Compliance state per policy assignment",
        "outputFile": "policy-compliance.json",
        "query": "policyresources\n| where type == 'microsoft.policyinsights/policystates'\n| extend complianceState = tostring(properties.complianceState)\n| summarize\n    Compliant = countif(complianceState == 'Compliant'),\n    NonCompliant = countif(complianceState == 'NonCompliant')\n    by policyAssignmentId = tostring(properties.policyAssignmentId)\n| extend ComplianceRate = round(100.0 * Compliant / (Compliant + NonCompliant), 1)"
      },
      "policyEnforcementSummary": {
        "name": "Policy Enforcement Summary",
        "description": "Count of policies by enforcement mode",
        "outputFile": "policy-enforcement.json",
        "query": "policyresources\n| where type == 'microsoft.authorization/policyassignments'\n| extend enforcementMode = tostring(properties.enforcementMode)\n| summarize Count = count() by enforcementMode"
      }
    },
    "security": {
      "keyVaults": {
        "name": "Key Vault Configuration",
        "description": "Security settings for Key Vaults",
        "outputFile": "keyvaults.csv",
        "query": "resources\n| where type == 'microsoft.keyvault/vaults'\n| extend\n    softDelete = properties.enableSoftDelete,\n    purgeProtection = properties.enablePurgeProtection,\n    rbacAuth = properties.enableRbacAuthorization,\n    publicNetwork = properties.publicNetworkAccess\n| project\n    Name = name,\n    ResourceGroup = resourceGroup,\n    Location = location,\n    SoftDelete = softDelete,\n    PurgeProtection = purgeProtection,\n    RBACAuth = rbacAuth,\n    PublicAccess = publicNetwork"
      },
      "nsgs": {
        "name": "Network Security Groups",
        "description": "NSG inventory with rule counts",
        "outputFile": "nsgs.json",
        "query": "resources\n| where type == 'microsoft.network/networksecuritygroups'\n| extend ruleCount = array_length(properties.securityRules)\n| project\n    Name = name,\n    ResourceGroup = resourceGroup,\n    Location = location,\n    RuleCount = ruleCount,\n    ResourceId = id"
      },
      "nsgRulesDetail": {
        "name": "NSG Rules Detail",
        "description": "All NSG rules for security review",
        "outputFile": "nsg-rules.csv",
        "query": "resources\n| where type == 'microsoft.network/networksecuritygroups'\n| mv-expand rule = properties.securityRules\n| extend\n    ruleName = tostring(rule.name),\n    direction = tostring(rule.properties.direction),\n    access = tostring(rule.properties.access),\n    priority = toint(rule.properties.priority),\n    sourceAddress = tostring(rule.properties.sourceAddressPrefix),\n    destAddress = tostring(rule.properties.destinationAddressPrefix),\n    destPort = tostring(rule.properties.destinationPortRange)\n| project\n    NSGName = name,\n    RuleName = ruleName,\n    Direction = direction,\n    Access = access,\n    Priority = priority,\n    SourceAddress = sourceAddress,\n    DestAddress = destAddress,\n    DestPort = destPort"
      },
      "storageAccountSecurity": {
        "name": "Storage Account Security",
        "description": "Security configuration for storage accounts",
        "outputFile": "storage-security.csv",
        "query": "resources\n| where type =~ 'microsoft.storage/storageaccounts'\n| extend\n    httpsOnly = properties.supportsHttpsTrafficOnly,\n    minTLS = properties.minimumTlsVersion,\n    publicAccess = properties.allowBlobPublicAccess,\n    networkDefaultAction = properties.networkAcls.defaultAction\n| project\n    Name = name,\n    ResourceGroup = resourceGroup,\n    HTTPSOnly = httpsOnly,\n    MinTLS = minTLS,\n    PublicBlobAccess = publicAccess,\n    NetworkDefault = networkDefaultAction"
      },
      "publicIPs": {
        "name": "Public IP Addresses",
        "description": "Public IPs - attack surface assessment",
        "outputFile": "public-ips.json",
        "query": "resources\n| where type == 'microsoft.network/publicipaddresses'\n| project\n    Name = name,\n    ResourceGroup = resourceGroup,\n    Location = location,\n    IPAddress = properties.ipAddress,\n    AllocationMethod = properties.publicIPAllocationMethod,\n    SKU = tostring(sku.name)"
      },
      "sqlServerSecurity": {
        "name": "SQL Server Security",
        "description": "SQL Server security settings",
        "outputFile": "sql-security.csv",
        "query": "resources\n| where type == 'microsoft.sql/servers'\n| extend\n    adminLogin = properties.administratorLogin,\n    publicNetwork = properties.publicNetworkAccess,\n    minTLS = properties.minimalTlsVersion\n| project\n    Name = name,\n    ResourceGroup = resourceGroup,\n    Location = location,\n    AdminLogin = adminLogin,\n    PublicNetwork = publicNetwork,\n    MinTLS = minTLS"
      }
    },
    "network": {
      "virtualNetworks": {
        "name": "Virtual Networks",
        "description": "VNets for hub-spoke planning",
        "outputFile": "vnets.json",
        "query": "resources\n| where type == 'microsoft.network/virtualnetworks'\n| extend\n    addressSpace = tostring(properties.addressSpace.addressPrefixes),\n    subnetCount = array_length(properties.subnets),\n    peeringCount = array_length(properties.virtualNetworkPeerings),\n    dnsServers = tostring(properties.dhcpOptions.dnsServers)\n| project\n    Name = name,\n    ResourceGroup = resourceGroup,\n    Location = location,\n    AddressSpace = addressSpace,\n    SubnetCount = subnetCount,\n    PeeringCount = peeringCount,\n    DNSServers = dnsServers"
      },
      "subnets": {
        "name": "Subnet Configuration",
        "description": "All subnets with NSG and route table associations",
        "outputFile": "subnets.csv",
        "query": "resources\n| where type == 'microsoft.network/virtualnetworks'\n| mv-expand subnet = properties.subnets\n| extend\n    subnetName = tostring(subnet.name),\n    addressPrefix = tostring(subnet.properties.addressPrefix),\n    nsg = tostring(subnet.properties.networkSecurityGroup.id),\n    routeTable = tostring(subnet.properties.routeTable.id)\n| project\n    VNetName = name,\n    SubnetName = subnetName,\n    AddressPrefix = addressPrefix,\n    NSG = iif(isempty(nsg), 'None', split(nsg, '/')[-1]),\n    RouteTable = iif(isempty(routeTable), 'None', split(routeTable, '/')[-1])"
      },
      "subnetsWithoutNSG": {
        "name": "Subnets Without NSG",
        "description": "Security gap - subnets missing NSG",
        "outputFile": "subnets-no-nsg.csv",
        "query": "resources\n| where type == 'microsoft.network/virtualnetworks'\n| mv-expand subnet = properties.subnets\n| extend\n    subnetName = tostring(subnet.name),\n    nsgAssigned = isnotempty(subnet.properties.networkSecurityGroup.id)\n| where nsgAssigned == false\n| project VNetName = name, SubnetName = subnetName, Location = location"
      },
      "vnetPeerings": {
        "name": "VNet Peerings",
        "description": "Existing network topology connections",
        "outputFile": "peerings.json",
        "query": "resources\n| where type == 'microsoft.network/virtualnetworks'\n| mv-expand peering = properties.virtualNetworkPeerings\n| extend\n    peeringName = tostring(peering.name),\n    peeringState = tostring(peering.properties.peeringState),\n    remoteVNet = tostring(peering.properties.remoteVirtualNetwork.id),\n    allowForwarding = peering.properties.allowForwardedTraffic,\n    allowGateway = peering.properties.allowGatewayTransit\n| project\n    VNetName = name,\n    PeeringName = peeringName,\n    State = peeringState,\n    RemoteVNet = split(remoteVNet, '/')[-1],\n    AllowForwarding = allowForwarding,\n    AllowGateway = allowGateway"
      },
      "connectivityResources": {
        "name": "Network Connectivity Resources",
        "description": "Firewalls, gateways, load balancers, etc.",
        "outputFile": "network-connectivity.json",
        "query": "resources\n| where type in~ (\n    'microsoft.network/publicipaddresses',\n    'microsoft.network/loadbalancers',\n    'microsoft.network/applicationgateways',\n    'microsoft.network/azurefirewalls',\n    'microsoft.network/bastionhosts',\n    'microsoft.network/virtualnetworkgateways',\n    'microsoft.network/expressroutecircuits',\n    'microsoft.network/privatednszones',\n    'microsoft.network/privateendpoints'\n)\n| project\n    Name = name,\n    Type = type,\n    ResourceGroup = resourceGroup,\n    Location = location,\n    SKU = tostring(sku.name)"
      },
      "privateEndpoints": {
        "name": "Private Endpoints",
        "description": "Private endpoint connectivity",
        "outputFile": "private-endpoints.json",
        "query": "resources\n| where type == 'microsoft.network/privateendpoints'\n| extend\n    targetResource = tostring(properties.privateLinkServiceConnections[0].properties.privateLinkServiceId),\n    connectionState = tostring(properties.privateLinkServiceConnections[0].properties.privateLinkServiceConnectionState.status)\n| project\n    Name = name,\n    ResourceGroup = resourceGroup,\n    Location = location,\n    TargetResource = split(targetResource, '/')[-1],\n    ConnectionState = connectionState"
      }
    },
    "identity": {
      "managedIdentities": {
        "name": "User Assigned Managed Identities",
        "description": "Managed identities for RBAC planning",
        "outputFile": "managed-identities.json",
        "query": "resources\n| where type == 'microsoft.managedidentity/userassignedidentities'\n| project\n    Name = name,\n    ResourceGroup = resourceGroup,\n    Location = location,\n    ClientId = properties.clientId,\n    PrincipalId = properties.principalId"
      },
      "roleAssignmentsSummary": {
        "name": "Role Assignments by Type",
        "description": "Summary of RBAC assignments",
        "outputFile": "rbac-summary.json",
        "query": "authorizationresources\n| where type == 'microsoft.authorization/roleassignments'\n| extend principalType = tostring(properties.principalType)\n| summarize Count = count() by principalType"
      },
      "roleAssignmentsDetail": {
        "name": "Role Assignments Detail",
        "description": "Full RBAC assignments list",
        "outputFile": "rbac-assignments.json",
        "query": "authorizationresources\n| where type == 'microsoft.authorization/roleassignments'\n| extend\n    principalId = tostring(properties.principalId),\n    principalType = tostring(properties.principalType),\n    roleDefId = tostring(properties.roleDefinitionId),\n    scope = tostring(properties.scope)\n| extend roleDefName = split(roleDefId, '/')[-1]\n| project\n    PrincipalId = principalId,\n    PrincipalType = principalType,\n    RoleDefinitionId = roleDefName,\n    Scope = scope"
      },
      "customRoleDefinitions": {
        "name": "Custom Role Definitions",
        "description": "Custom RBAC roles",
        "outputFile": "custom-roles.json",
        "query": "authorizationresources\n| where type == 'microsoft.authorization/roledefinitions'\n| where properties.type == 'CustomRole'\n| project\n    Name = properties.roleName,\n    Description = properties.description,\n    Permissions = properties.permissions"
      }
    },
    "dataAndAI": {
      "analyticsServices": {
        "name": "Analytics & AI Services",
        "description": "Data platform resources",
        "outputFile": "data-ai-resources.json",
        "query": "resources\n| where type in~ (\n    'microsoft.synapse/workspaces',\n    'microsoft.databricks/workspaces',\n    'microsoft.machinelearningservices/workspaces',\n    'microsoft.cognitiveservices/accounts',\n    'microsoft.search/searchservices',\n    'microsoft.datafactory/factories',\n    'microsoft.purview/accounts',\n    'microsoft.eventhub/namespaces',\n    'microsoft.streamanalytics/streamingjobs',\n    'microsoft.kusto/clusters'\n)\n| project\n    Name = name,\n    Type = type,\n    ResourceGroup = resourceGroup,\n    Location = location,\n    SKU = tostring(sku.name),\n    Kind = kind"
      },
      "databases": {
        "name": "Database Services",
        "description": "All database resources",
        "outputFile": "databases.json",
        "query": "resources\n| where type in~ (\n    'microsoft.sql/servers',\n    'microsoft.sql/servers/databases',\n    'microsoft.documentdb/databaseaccounts',\n    'microsoft.dbforpostgresql/flexibleservers',\n    'microsoft.dbformysql/flexibleservers',\n    'microsoft.cache/redis'\n)\n| project\n    Name = name,\n    Type = type,\n    ResourceGroup = resourceGroup,\n    Location = location,\n    SKU = tostring(sku.name)"
      },
      "storageDataLake": {
        "name": "Storage Accounts (Data Lake)",
        "description": "Storage with Data Lake assessment",
        "outputFile": "storage-datalake.json",
        "query": "resources\n| where type =~ 'microsoft.storage/storageaccounts'\n| extend\n    kind = kind,\n    accessTier = properties.accessTier,\n    isHnsEnabled = properties.isHnsEnabled\n| project\n    Name = name,\n    ResourceGroup = resourceGroup,\n    Location = location,\n    Kind = kind,\n    AccessTier = accessTier,\n    DataLakeEnabled = isHnsEnabled,\n    SKU = tostring(sku.name)"
      }
    },
    "mcsbCompliance": {
      "storageMCSBv1": {
        "name": "Storage: MCSB v1 Compliance",
        "description": "Storage account MCSB v1 control assessment",
        "outputFile": "mcsb-v1-storage.csv",
        "query": "resources\n| where type =~ 'microsoft.storage/storageaccounts'\n| extend\n    httpsOnly = tostring(properties.supportsHttpsTrafficOnly),\n    minTLS = tostring(properties.minimumTlsVersion),\n    networkDefault = tostring(properties.networkAcls.defaultAction)\n| extend\n    DP3_DataInTransit = iif(httpsOnly == 'true' and minTLS == 'TLS1_2', 'Compliant', 'Non-Compliant'),\n    NS2_NetworkSegmentation = iif(networkDefault == 'Deny', 'Compliant', 'Review')\n| project\n    Name = name,\n    HTTPSOnly = httpsOnly,\n    MinTLS = minTLS,\n    NetworkDefault = networkDefault,\n    MCSB_v1_DP3 = DP3_DataInTransit,\n    MCSB_v1_NS2 = NS2_NetworkSegmentation"
      },
      "storageMCSBv2": {
        "name": "Storage: MCSB v2 Compliance",
        "description": "Storage account MCSB v2 control assessment",
        "outputFile": "mcsb-v2-storage.csv",
        "query": "resources\n| where type =~ 'microsoft.storage/storageaccounts'\n| extend\n    httpsOnly = tostring(properties.supportsHttpsTrafficOnly),\n    minTLS = tostring(properties.minimumTlsVersion),\n    networkDefault = tostring(properties.networkAcls.defaultAction),\n    publicAccess = tostring(properties.allowBlobPublicAccess)\n| extend\n    DP3_v2 = iif(httpsOnly == 'true' and minTLS == 'TLS1_2', 'Compliant', 'Non-Compliant'),\n    NS2_v2 = iif(networkDefault == 'Deny', 'Compliant', 'Review'),\n    DP1_v2 = iif(publicAccess == 'false', 'Compliant', 'Review')\n| project\n    Name = name,\n    HTTPSOnly = httpsOnly,\n    MinTLS = minTLS,\n    NetworkDefault = networkDefault,\n    PublicBlobAccess = publicAccess,\n    MCSB_v2_DP3 = DP3_v2,\n    MCSB_v2_NS2 = NS2_v2,\n    MCSB_v2_DP1 = DP1_v2"
      },
      "keyVaultMCSBv1": {
        "name": "Key Vault: MCSB v1 Compliance",
        "description": "Key Vault MCSB v1 control assessment",
        "outputFile": "mcsb-v1-keyvault.csv",
        "query": "resources\n| where type == 'microsoft.keyvault/vaults'\n| extend\n    softDelete = tostring(properties.enableSoftDelete),\n    purgeProtection = tostring(properties.enablePurgeProtection),\n    rbacAuth = tostring(properties.enableRbacAuthorization)\n| extend\n    DP5_DataAtRest = iif(softDelete == 'true' and purgeProtection == 'true', 'Compliant', 'Non-Compliant'),\n    IM1_IdentityMgmt = iif(rbacAuth == 'true', 'Compliant', 'Review')\n| project\n    Name = name,\n    SoftDelete = softDelete,\n    PurgeProtection = purgeProtection,\n    RBACAuth = rbacAuth,\n    MCSB_v1_DP5 = DP5_DataAtRest,\n    MCSB_v1_IM1 = IM1_IdentityMgmt"
      },
      "keyVaultMCSBv2": {
        "name": "Key Vault: MCSB v2 Compliance",
        "description": "Key Vault MCSB v2 control assessment",
        "outputFile": "mcsb-v2-keyvault.csv",
        "query": "resources\n| where type == 'microsoft.keyvault/vaults'\n| extend\n    softDelete = tostring(properties.enableSoftDelete),\n    purgeProtection = tostring(properties.enablePurgeProtection),\n    rbacAuth = tostring(properties.enableRbacAuthorization),\n    publicNetwork = tostring(properties.publicNetworkAccess)\n| extend\n    DP5_v2 = iif(softDelete == 'true' and purgeProtection == 'true', 'Compliant', 'Non-Compliant'),\n    IM1_v2 = iif(rbacAuth == 'true', 'Compliant', 'Review'),\n    NS2_v2 = iif(publicNetwork == 'Disabled', 'Compliant', 'Review')\n| project\n    Name = name,\n    SoftDelete = softDelete,\n    PurgeProtection = purgeProtection,\n    RBACAuth = rbacAuth,\n    PublicNetwork = publicNetwork,\n    MCSB_v2_DP5 = DP5_v2,\n    MCSB_v2_IM1 = IM1_v2,\n    MCSB_v2_NS2 = NS2_v2"
      },
      "networkMCSBv2": {
        "name": "Network: MCSB v2 NS-1 Compliance",
        "description": "Network boundary control assessment",
        "outputFile": "mcsb-v2-network.csv",
        "query": "resources\n| where type == 'microsoft.network/virtualnetworks'\n| mv-expand subnet = properties.subnets\n| extend\n    subnetName = tostring(subnet.name),\n    nsgAssigned = isnotempty(subnet.properties.networkSecurityGroup.id)\n| extend\n    NS1_v2 = iif(nsgAssigned, 'Compliant', 'Non-Compliant')\n| project\n    VNetName = name,\n    SubnetName = subnetName,\n    NSGAssigned = nsgAssigned,\n    MCSB_v2_NS1 = NS1_v2"
      }
    }
  },
  "cliExamples": {
    "singleQuery": "az graph query -q \"resources | summarize count() by type\" --output json > inventory.json",
    "allSubscriptions": "az graph query -q \"resources | project name, type, location\" --subscriptions \"sub1\" \"sub2\" --output json",
    "exportToCSV": "az graph query -q \"resources | project name, type, location, resourceGroup\" --output tsv > inventory.tsv",
    "runAllQueries": "# Bash script to run all queries\nfor query in summary inventory governance security network identity dataAndAI mcsbCompliance; do\n  az graph query -q \"$(cat kql-queries.json | jq -r \".queries.$query | to_entries[] | .value.query\")\" --output json > \"$query.json\"\ndone"
  },
  "powershellExamples": {
    "singleQuery": "Search-AzGraph -Query \"resources | summarize count() by type\" | ConvertTo-Json -Depth 10 | Out-File inventory.json",
    "allSubscriptions": "$subs = Get-AzSubscription | Select-Object -ExpandProperty Id; Search-AzGraph -Query \"resources\" -Subscription $subs"
  }
}
